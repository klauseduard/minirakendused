<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-R2CD8VG3XC"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        
        gtag('config', 'G-R2CD8VG3XC', {
            'page_path': '/minirakendused/gardening_calendar'
        });
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Gardening and Planting Calendar</title>
    <style>
        :root {
            --primary-color: #4a8e3a;
            --secondary-color: #8bc34a;
            --accent-color: #3e7d32;
            --light-bg: #f1f8e9;
            --dark-bg: #e8f5e9;
            --white: #ffffff;
            --black: #212121;
            --shadow: rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--light-bg);
            color: var(--black);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin: -20px -20px 20px -20px;  /* Negative margin to span full width */
            padding: 15px 20px;
            background-color: var(--primary-color);
            color: var(--white);
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 8px var(--shadow);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        /* Add transition for smooth shadow change on scroll */
        header.scrolled {
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        /* Compact header on scroll */
        header.scrolled h1 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .description {
            font-size: 1rem;
            font-weight: 400;
            color: #224c2a;
            margin: 0 auto;
            max-width: 700px;
        }
        
        .main-layout {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .top-controls {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .location-row {
            display: grid;
            grid-template-columns: minmax(250px, 520px) auto;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        .units-row {
            display: flex;
            gap: 25px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .unit-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .weather-display {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .search-bar {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .search-section-title {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 500;
        }

        .search-container {
            width: 100%;
        }

        .search-box {
            width: 100%;
            padding: 12px 20px;
            font-size: 1rem;
            border: 2px solid var(--secondary-color);
            border-radius: 30px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .search-box:focus {
            border-color: var(--primary-color);
        }

        .month-navigation {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .month-nav-title {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 500;
        }

        .calendar-nav {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .month-btn {
            padding: 12px 25px;
            background-color: var(--secondary-color);
            color: var(--white);
            border: none;
            border-radius: 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px var(--shadow);
            min-width: 120px;
            text-align: center;
        }

        .month-btn:hover {
            background-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .month-btn.active {
            background-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow);
        }

        .scroll-indicator {
            text-align: center;
            padding: 15px;
            color: var(--primary-color);
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            margin-bottom: 25px;
        }

        .scroll-indicator:hover {
            transform: translateY(2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .scroll-indicator-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .scroll-indicator-text {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--primary-color);
        }

        .scroll-arrow {
            font-size: 1.5rem;
            animation: bounce 2s infinite;
            color: var(--secondary-color);
        }

        .scroll-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--secondary-color);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px var(--shadow);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            transform: translateY(20px);
            z-index: 100;
            border: none;
        }

        .scroll-to-top.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .scroll-to-top:hover {
            background: var(--accent-color);
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0;  /* Remove padding on mobile */
            }

            header {
                margin: 0;  /* Remove negative margins on mobile */
                padding: 10px;
            }

            header.scrolled {
                padding: 8px;
            }

            h1 {
                font-size: 1.6rem;
                margin-bottom: 12px;
            }

            header.scrolled h1 {
                font-size: 1.3rem;
                margin-bottom: 8px;
            }

            .quick-jump-menu {
                padding: 8px;
                gap: 6px;
            }
            
            .quick-jump-btn {
                padding: 6px 12px;
                font-size: 0.9rem;
                min-width: calc(50% - 6px);
            }

            header.scrolled .quick-jump-btn {
                padding: 4px 10px;
                font-size: 0.85rem;
            }
        }

        .calendar-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .category-card {
            background-color: var(--white);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px var(--shadow);
            transition: transform 0.3s ease;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .category-card:last-child {
            grid-column: 1 / -1;
        }

        .garden-tasks-card {
            grid-column: 1 / -1;
        }
        
        .category-card .plant-list {
            flex-grow: 1;
        }
        
        .category-card:hover {
            transform: translateY(-5px);
        }
        
        .category-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .category-icon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
            background-color: var(--secondary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-size: 1.2rem;
        }
        
        .category-title {
            font-size: 1.3rem;
            color: var(--primary-color);
        }
        
        .plant-list {
            list-style-type: none;
        }
        
        .plant-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
        }
        
        .plant-item:last-child {
            border-bottom: none;
        }
        
        .plant-item::before {
            content: "üå±";
            margin-right: 10px;
        }
        
        .task-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
        }
        
        .task-item:last-child {
            border-bottom: none;
        }
        
        .task-item::before {
            content: "‚úì";
            margin-right: 10px;
        }
        
        .item-label {
            width: 100%;
            padding: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .item-label:hover {
            background: var(--light-bg);
        }

        .item-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary-color);
            margin: 0;
        }

        .item-text {
            flex: 1;
            padding: 2px 0;
        }
        
        .highlight {
            background-color: #ffe066;
            padding: 2px;
            border-radius: 3px;
        }
        
        .no-results {
            text-align: center;
            padding: 20px;
            font-size: 1.2rem;
            color: #757575;
            grid-column: 1 / -1;
        }
        
        .mobile-warning {
            display: none;
            text-align: center;
            padding: 10px;
            background-color: #fff3e0;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        
        @media (max-width: 768px) {
            .location-row {
                grid-template-columns: 1fr;
            }
            
            .search-bar {
                flex-direction: column;
            }
            
            .search-container {
                width: 100%;
            }
            
            .ai-advice-btn {
                width: 100%;
            }
            
            .mobile-warning {
                display: block;
            }
        }

        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: static;
            }

            .action-bar {
                flex-direction: column;
            }

            .search-container {
                width: 100%;
            }

            .ai-advice-btn {
                width: 100%;
                justify-content: center;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease forwards;
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #757575;
            font-size: 0.9rem;
        }
        
        .weather-section {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 15px;
        }
        
        .weather-location-row {
            margin-bottom: 10px;
        }
        
        .weather-location-info {
            margin-bottom: 18px;
            font-size: 1.08em;
        }
        
        .weather-forecast-table {
            width: 100%;
            font-size: 0.97em;
            margin-top: 10px;
            border-collapse: separate;
            border-spacing: 0 6px;
            background: #f8faf5;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 4px rgba(74,142,58,0.07);
        }
        
        .weather-forecast-table th, .weather-forecast-table td {
            padding: 7px 14px;
            text-align: center;
        }
        
        .weather-forecast-table th {
            background: #e8f5e9;
            color: #3e7d32;
            font-weight: 600;
            border-bottom: 2px solid #c8e6c9;
        }
        
        .weather-forecast-table td {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .weather-forecast-table tr:last-child td {
            border-bottom: none;
        }
        
        .weather-forecast-table td svg {
            display: block;
            margin: 0 auto;
            cursor: pointer;
        }
        
        .weather-current {
            margin-bottom: 10px;
            font-size: 1.08em;
        }
        
        .location-input {
            padding: 10px 16px;
            border: 2px solid var(--secondary-color);
            border-radius: 30px;
            font-size: 1rem;
            outline: none;
            width: 100%;
            box-sizing: border-box;
        }
        
        .location-input-group {
            position: relative;
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 520px;
        }
        
        .location-clear-btn {
            position: absolute;
            right: 15px;
            background: none;
            border: none;
            cursor: pointer;
            color: #999;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }
        
        .location-clear-btn:hover {
            background-color: rgba(0,0,0,0.05);
            color: #666;
        }
        
        .location-btn {
            padding: 10px 18px;
            background-color: var(--secondary-color);
            color: var(--white);
            border: none;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .location-btn:hover {
            background-color: var(--accent-color);
        }
        
        .weather-placeholder {
            color: #333;
            font-size: 1.1rem;
        }
        
        /* Modal for detailed weather */
        .weather-modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.25);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .weather-modal {
            background: var(--light-bg);
            border-radius: 14px;
            box-shadow: 0 4px 24px var(--shadow);
            padding: 28px 32px 24px 32px;
            min-width: 340px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .weather-modal-close {
            position: absolute;
            top: 10px;
            right: 16px;
            font-size: 1.4em;
            color: #7cb342;
            background: none;
            border: none;
            cursor: pointer;
            transition: color 0.2s;
        }
        .weather-modal-close:hover {
            color: #388e3c;
        }
        .weather-modal-title {
            font-size: 1.18em;
            margin-bottom: 18px;
            color: var(--primary-color);
            font-weight: 600;
            letter-spacing: 0.01em;
        }
        .weather-modal-chart {
            margin-bottom: 18px;
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 1px 4px var(--shadow);
            padding: 12px 8px 8px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .weather-modal-hourly-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 4px;
            font-size: 0.98em;
            background: #f8faf5;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 4px rgba(74,142,58,0.07);
            margin-top: 8px;
        }
        .weather-modal-hourly-table th, .weather-modal-hourly-table td {
            padding: 6px 12px;
            text-align: center;
        }
        .weather-modal-hourly-table th {
            background: #e8f5e9;
            color: #3e7d32;
            font-weight: 600;
        }
        .weather-modal-hourly-table td {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
        }
        .weather-modal-hourly-table tr:last-child td {
            border-bottom: none;
        }
        .weather-forecast-table tr:nth-child(even) td,
        .weather-modal-hourly-table tr:nth-child(even) td {
            background: #f1f8e9;
        }
        /* Visually hidden class for accessibility */
        .visually-hidden {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }

        /* AI Assistants Grid Styles */
        .ai-assistants-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .ai-assistant-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 15px 10px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .ai-assistant-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
            border-color: var(--secondary-color);
        }

        .ai-assistant-btn:active {
            transform: translateY(0);
        }

        .ai-logo {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .ai-assistant-btn span {
            font-weight: 500;
            color: #333;
        }

        @media (max-width: 600px) {
            .ai-assistants-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .month-btn:focus, .location-btn:focus, .weather-modal-close:focus {
            outline: 3px solid #1976d2 !important;
            outline-offset: 2px;
        }
        .item-label {
            width: 100%;
            padding: 4px 0;
        }
        .item-label:hover {
            background: var(--light-bg);
        }
        .item-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary-color);
        }
        .item-text {
            flex: 1;
        }
        .quick-jump-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 15px;
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .quick-jump-title {
            width: 100%;
            text-align: center;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 5px;
            font-weight: 500;
        }

        .quick-jump-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            justify-content: center;
        }

        .nav-icon {
            font-size: 1.2em;
            display: inline-block;
            transform: translateY(-1px);
        }

        .quick-jump-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .quick-jump-btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
        }

        .quick-jump-btn.active {
            background: white;
            color: var(--primary-color);
            border-color: white;
        }

        @media (max-width: 768px) {
            header {
                padding: 10px;
                top: 0;
                border-radius: 0;
                margin: -20px -20px 20px -20px;
                width: calc(100% + 40px);
            }

            h1 {
                font-size: 1.6rem;
                margin-bottom: 12px;
            }

            .quick-jump-menu {
                padding: 8px;
                gap: 6px;
            }
            
            .quick-jump-btn {
                padding: 6px 12px;
                font-size: 0.9rem;
                min-width: calc(50% - 6px);
            }

            .nav-icon {
                font-size: 1.1em;
            }
        }

        .ai-icon {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Spring Gardening and Planting Calendar</h1>
            <div class="quick-jump-menu" id="quickJumpMenu">
                <div class="quick-jump-title">Quick Navigation:</div>
                <button class="quick-jump-btn" data-section="location-setup">
                    <span class="nav-icon">üìç</span> Location Setup
                </button>
                <button class="quick-jump-btn" data-section="weather-info">
                    <span class="nav-icon">üå§Ô∏è</span> Weather Info
                </button>
                <button class="quick-jump-btn" data-section="search-section">
                    <span class="nav-icon">üîç</span> Search & Advice
                </button>
                <button class="quick-jump-btn" data-section="monthly-calendar">
                    <span class="nav-icon">üìÖ</span> Monthly Calendar
                </button>
            </div>
        </header>

        <main class="main-layout">
            <!-- Location and Units Controls -->
            <section class="top-controls" id="location-setup">
                <div class="location-row">
                    <div class="location-input-group">
                        <label for="locationInput" class="visually-hidden">Location</label>
                        <input type="text" class="location-input" id="locationInput" 
                            placeholder="City or place name (e.g., Paris, Barcelona)" 
                            aria-label="Location">
                        <button type="button" id="clearLocationBtn" class="location-clear-btn" 
                            aria-label="Clear location" style="display: none;">√ó</button>
                    </div>
                    <button class="location-btn" id="useMyLocationBtn">Use my location</button>
                </div>
                <div class="units-row">
                    <div class="unit-group">
                        <label for="tempUnitSelect">Temperature:</label>
                        <select id="tempUnitSelect" aria-label="Temperature unit">
                            <option value="C">Celsius (¬∞C)</option>
                            <option value="F">Fahrenheit (¬∞F)</option>
                        </select>
                    </div>
                    <div class="unit-group">
                        <label for="precipUnitSelect">Precipitation:</label>
                        <select id="precipUnitSelect" aria-label="Precipitation unit">
                            <option value="mm">Millimeters (mm)</option>
                            <option value="in">Inches (in)</option>
                        </select>
                    </div>
                </div>
                <div id="climateZoneInfo"></div>
            </section>

            <!-- Weather Display -->
            <section class="weather-display" id="weather-info">
                <div class="weather-placeholder" id="weatherPlaceholder">
                    Weather information for your location will appear here.
                </div>
            </section>

            <!-- Search Bar -->
            <section class="search-bar" id="search-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 class="search-section-title">Find Plants and Tasks</h2>
                    <button id="aiAdviceBtn" class="ai-advice-btn" style="padding: 8px 16px; background: var(--secondary-color); color: white; border: none; border-radius: 20px; display: flex; align-items: center; gap: 8px; font-weight: 500; cursor: pointer; transition: background-color 0.3s;">
                        <span style="font-size: 1.2em;">ü§ñ</span>
                        <span>Generate AI gardening advice prompt</span>
                    </button>
                </div>
                <div class="search-container">
                    <label for="searchBox" class="visually-hidden">Search for plants or tasks</label>
                    <input type="text" class="search-box" id="searchBox" 
                        placeholder="Type to search for specific plants or garden tasks..." 
                        aria-label="Search for plants or tasks">
                </div>
            </section>

            <!-- Month Navigation -->
            <section class="month-navigation" id="monthly-calendar">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 class="month-nav-title">Select Growing Period</h2>
                </div>
                <div class="calendar-nav">
                    <button class="month-btn active" data-month="april">April</button>
                    <button class="month-btn" data-month="may">May</button>
                    <button class="month-btn" data-month="early_june">Early June</button>
                </div>
            </section>

            <!-- Calendar Content -->
            <section class="calendar-content" id="calendarContent">
                <!-- Content will be added by JavaScript -->
            </section>

            <button class="scroll-to-top" id="scrollToTop" aria-label="Scroll to top" style="display: none;">
                ‚Üë
            </button>
        </main>

        <!-- Prompt Generator Modal -->
        <div id="promptGeneratorModal" class="weather-modal-overlay" style="display: none;">
            <div class="weather-modal" style="width: 90%; max-width: 800px;">
                <button class="weather-modal-close" id="closePromptGeneratorBtn" aria-label="Close prompt generator">&times;</button>
                <div class="weather-modal-title">AI Gardening Assistant</div>
                <div style="margin: 20px 0;">
                    <p style="margin-bottom: 15px; color: #666;">
                        This tool will generate a comprehensive prompt based on your location, weather, and garden information. 
                        You can use this prompt with any AI assistant to get personalized gardening advice.
                    </p>
                    <div style="margin-bottom: 15px;">
                        <label for="customNotes" style="display: block; margin-bottom: 8px; font-weight: 500;">Your notes about your garden:</label>
                        <textarea id="customNotes" rows="4" style="width: 100%; padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; margin-bottom: 10px;" placeholder="Describe your garden's current state, what you've already done, or ask specific questions..."></textarea>
                    </div>
                    <div style="margin-bottom: 15px; padding: 12px; background: #fff3e0; border-radius: 8px;">
                        <h3 style="margin-bottom: 10px; color: #e65100; font-size: 1rem;">Include in Prompt:</h3>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="display: block;">
                                <input type="checkbox" id="includeCalendar" checked>
                                Selected plants and tasks
                                <span style="margin-left: 5px; color: #666; font-size: 0.9em;">
                                    (Your checked items from the planting calendar)
                                </span>
                            </label>
                            <label style="display: block;">
                                <input type="checkbox" id="includeRelevantPlantsOnly" checked>
                                Filter for weather conditions
                                <span style="margin-left: 5px; color: #666; font-size: 0.9em;">
                                    (Only include plants suitable for current forecast)
                                </span>
                            </label>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button id="generatePromptBtn" class="location-btn">Generate Prompt</button>
                        <button id="copyPromptBtn" class="location-btn" style="background: var(--accent-color);">Copy to Clipboard</button>
                    </div>
                    <div id="generatedPrompt" style="background: #f8faf5; border-radius: 8px; padding: 15px; white-space: pre-wrap; font-family: monospace; max-height: 400px; overflow-y: auto;">
                        Click "Generate Prompt" to create a customized gardening prompt based on your location, weather, and calendar data.
                    </div>
                    
                    <!-- AI Assistants Integration -->
                    <div id="promptDestinationSection" style="margin-top: 20px; display: none;">
                        <h3 style="margin-bottom: 15px; font-size: 1.1rem; color: var(--primary-color);">Send Prompt Directly To:</h3>
                        <div class="ai-assistants-grid">
                            <button class="ai-assistant-btn" data-assistant="chatgpt">
                                <div class="ai-icon" style="background-color: #10a37f; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                                    </svg>
                                </div>
                                <span>ChatGPT</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="claude">
                                <div class="ai-icon" style="background-color: #9A5CF2; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M12 16v-4"></path>
                                        <path d="M12 8h.01"></path>
                                    </svg>
                                </div>
                                <span>Claude</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="gemini">
                                <div class="ai-icon" style="background-color: #1E88E5; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                                    </svg>
                                </div>
                                <span>Gemini</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="copilot">
                                <div class="ai-icon" style="background-color: #0F6CBD; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M9 18l6-6-6-6"></path>
                                    </svg>
                                </div>
                                <span>Copilot</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="mistral">
                                <div class="ai-icon" style="background-color: #DE5833; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M20 12V8H6a2 2 0 1 1 0-4h12v4"></path>
                                        <path d="M4 12v4h14a2 2 0 1 1 0 4H4v-4"></path>
                                    </svg>
                                </div>
                                <span>Mistral</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="deepseek">
                                <div class="ai-icon" style="background-color: #1B7A9F; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="5"></circle>
                                        <line x1="12" y1="1" x2="12" y2="3"></line>
                                        <line x1="12" y1="21" x2="12" y2="23"></line>
                                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                                        <line x1="1" y1="12" x2="3" y2="12"></line>
                                        <line x1="21" y1="12" x2="23" y2="12"></line>
                                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                                    </svg>
                                </div>
                                <span>DeepSeek</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Spring Gardening and Planting Calendar ¬© 2025</p>
        </footer>
    </div>

    <script>
        // Data in JSON format
        const calendarData = {
            "april": {
                "direct_sowing": [
                    "carrot",
                    "parsnip",
                    "radish",
                    "turnip",
                    "peas",
                    "spinach",
                    "arugula",
                    "lettuce",
                    "dill",
                    "parsley"
                ],
                "seedling_start": [
                    "cabbage",
                    "cauliflower",
                    "broccoli",
                    "kale",
                    "tomato",
                    "pepper",
                    "eggplant",
                    "pumpkin",
                    "zucchini",
                    "melon",
                    "basil",
                    "thyme",
                    "sage"
                ],
                "greenhouse": [
                    "radish",
                    "spinach",
                    "lettuce",
                    "dill"
                ],
                "garden_tasks": [
                    "Pruning fruit trees and berry bushes (before bud break)",
                    "Cleaning strawberry beds",
                    "Turning compost",
                    "Cleaning and preparing greenhouse",
                    "Loosening and fertilizing beds"
                ]
            },
            "may": {
                "direct_sowing": [
                    "carrot",
                    "beetroot",
                    "radish",
                    "turnip",
                    "parsnip",
                    "dill",
                    "parsley",
                    "lettuce",
                    "arugula",
                    "spinach (new sowing)",
                    "chard",
                    "peas",
                    "beans",
                    "potato",
                    "onion (sets or seeds)"
                ],
                "transplanting": [
                    "cabbage",
                    "cauliflower",
                    "broccoli",
                    "kale",
                    "tomato (in greenhouse)",
                    "pepper (in greenhouse)",
                    "eggplant (in greenhouse)",
                    "zucchini (late May)",
                    "pumpkin (late May)"
                ],
                "greenhouse": [
                    "tomato",
                    "cucumber",
                    "pepper",
                    "eggplant",
                    "zucchini",
                    "basil"
                ],
                "garden_tasks": [
                    "Checking fruit tree flower buds (thinning if needed)",
                    "Planting containers and balcony plants",
                    "Adding mulch to beds",
                    "Weed control",
                    "Adding green matter to compost"
                ]
            },
            "early_june": {
                "direct_sowing": [
                    "beans (late varieties)",
                    "zucchini (direct sowing)",
                    "cucumber (direct sowing)"
                ],
                "transplanting": [
                    "zucchini",
                    "pumpkin",
                    "cucumber (if soil is warm)"
                ],
                "greenhouse": [
                    "Tomato maintenance and staking",
                    "Fertilizing",
                    "Ventilation",
                    "Removing side shoots",
                    "Succession planting (lettuce, radish, herbs)",
                    "Cucumber staking"
                ],
                "garden_tasks": [
                    "Removing row covers",
                    "Monitoring watering schedule",
                    "Weed control",
                    "Covering strawberries with bird netting"
                ]
            }
        };

        // Category icons
        const categoryIcons = {
            "direct_sowing": "üå±",
            "seedling_start": "üåø",
            "transplanting": "üåø",
            "greenhouse": "üè°",
            "garden_tasks": "üß∞"
        };

        // Category names
        const categoryNames = {
            "direct_sowing": "Direct Sowing",
            "seedling_start": "Starting Seedlings",
            "transplanting": "Transplanting",
            "greenhouse": "Greenhouse",
            "garden_tasks": "Garden Tasks"
        };

        // DOM elements
        const calendarContent = document.getElementById('calendarContent');
        const monthButtons = document.querySelectorAll('.month-btn');
        const searchBox = document.getElementById('searchBox');

        // Active month (default April)
        let activeMonth = 'april';

        // Track last actions for retry
        let lastGeocodeQuery = null;
        let lastWeatherCoords = null;
        let lastWeatherAction = null; // 'geocode' or 'weather'

        // Store last fetched weather data for re-rendering
        let lastWeatherData = null;
        let lastWeatherLat = null;
        let lastWeatherLon = null;

        // --- K√∂ppen climate zone logic ---
        let koppenGrid = null;
        let userClimateZone = null;
        let userClimateZoneOverride = null;
        const climateZoneInfo = document.getElementById('climateZoneInfo');

        // Load the grid JSON
        fetch('gardening_calendar/data/koppen_grid_0.5deg.json')
            .then(r => r.json())
            .then(data => {
                koppenGrid = data;
                // If we already have a location, try to show zone
                const cached = localStorage.getItem('gardening_last_location');
                if (cached) {
                    try {
                        const loc = JSON.parse(cached);
                        if (loc.type === 'coords' && loc.lat && loc.lon) {
                            showClimateZone(loc.lat, loc.lon);
                        }
                    } catch (e) {}
                }
            });

        // Helper: round to nearest 0.25
        function round025(x) {
            // Ensure x is a number and round to either .25 or .75
            const num = typeof x === 'string' ? parseFloat(x) : x;
            const decimal = num % 1;
            const whole = Math.floor(num);
            let rounded;
            if (decimal < 0.375) {
                rounded = 0.25;
            } else if (decimal < 0.875) {
                rounded = 0.75;
            } else {
                rounded = 0.25;
                return (whole + 1 + rounded).toFixed(2);
            }
            return (whole + rounded).toFixed(2);
        }

        // Show climate zone info
        function showClimateZone(lat, lon) {
            if (!koppenGrid) {
                climateZoneInfo.innerHTML = '';
                return;
            }
            // Check for override
            const override = localStorage.getItem('gardening_climate_zone_override');
            let lookupKey = '';
            let foundZone = '';
            if (override) {
                userClimateZoneOverride = override;
                userClimateZone = override;
                lookupKey = '(override)';
                foundZone = override;
            } else {
                const latNum = typeof lat === 'string' ? parseFloat(lat) : lat;
                const lonNum = typeof lon === 'string' ? parseFloat(lon) : lon;
                const key = `${round025(latNum)} ${round025(lonNum)}`;
                // Try exact match first
                if (koppenGrid[key]) {
                    userClimateZone = koppenGrid[key];
                    lookupKey = key;
                    foundZone = userClimateZone;
                } else {
                    // Find nearest neighbor
                    const roundedLat = round025(latNum);
                    const roundedLon = round025(lonNum);
                    let minDistance = Infinity;
                    let nearestZone = null;
                    let nearestKey = null;
                    
                    // Search in nearby coordinates (¬±1 degree should be enough)
                    for (const gridKey in koppenGrid) {
                        const [gridLat, gridLon] = gridKey.split(' ').map(Number);
                        if (Math.abs(gridLat - roundedLat) <= 1 && Math.abs(gridLon - roundedLon) <= 1) {
                            const distance = Math.sqrt(
                                Math.pow(gridLat - roundedLat, 2) + 
                                Math.pow(gridLon - roundedLon, 2)
                            );
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestZone = koppenGrid[gridKey];
                                nearestKey = gridKey;
                            }
                        }
                    }
                    
                    if (nearestZone) {
                        userClimateZone = nearestZone;
                        lookupKey = `${key} (nearest: ${nearestKey}, dist: ${minDistance.toFixed(2)}¬∞)`;
                        foundZone = nearestZone;
                    } else {
                        userClimateZone = 'Unknown';
                        lookupKey = key;
                        foundZone = 'Unknown';
                    }
                }
            }
            renderClimateZoneUI(lookupKey, foundZone);
        }

        // Render the climate zone UI (with debug info)
        function renderClimateZoneUI(lookupKey = '', foundZone = '') {
            let html = '';
            if (userClimateZone) {
                html += `<div style="margin-top: 15px; padding: 10px 15px; background: var(--white); border-radius: 8px; box-shadow: 0 1px 3px var(--shadow);">`;
                html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">`;
                html += `<strong>Climate zone:</strong> <span id="climateZoneCode" style="background: var(--light-bg); padding: 2px 8px; border-radius: 4px; font-family: monospace;">${userClimateZone}</span>`;
                html += `<a href="https://en.wikipedia.org/wiki/K%C3%B6ppen_climate_classification" target="_blank" style="color: var(--primary-color); text-decoration: none; font-size: 0.95em;">(What is this?)</a>`;
                html += `</div>`;
                html += `<div style="display: flex; align-items: center; gap: 10px;">`;
                html += `<label for="climateZoneOverride" style="font-size: 0.95em;">Override zone:</label>`;
                html += `<input id="climateZoneOverride" type="text" style="padding: 4px 8px; border: 1px solid var(--secondary-color); border-radius: 4px; width: 60px;" value="${userClimateZoneOverride || ''}" placeholder="e.g. Dfb">`;
                html += `<button id="setClimateZoneOverrideBtn" style="padding: 4px 10px; background: var(--secondary-color); color: white; border: none; border-radius: 4px; font-size: 0.95em; cursor: pointer;">Set</button>`;
                html += `<button id="clearClimateZoneOverrideBtn" style="padding: 4px 10px; background: var(--accent-color); color: white; border: none; border-radius: 4px; font-size: 0.95em; cursor: pointer;">Clear</button>`;
                html += `</div></div>`;
            }
            climateZoneInfo.innerHTML = html;

            // Add listeners
            const setBtn = document.getElementById('setClimateZoneOverrideBtn');
            const clearBtn = document.getElementById('clearClimateZoneOverrideBtn');
            if (setBtn) {
                setBtn.addEventListener('click', function() {
                    const val = document.getElementById('climateZoneOverride').value.trim();
                    if (val) {
                        localStorage.setItem('gardening_climate_zone_override', val);
                        userClimateZoneOverride = val;
                        userClimateZone = val;
                        renderClimateZoneUI();
                    }
                });
            }
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    localStorage.removeItem('gardening_climate_zone_override');
                    userClimateZoneOverride = null;
                    // Recompute from location
                    const cached = localStorage.getItem('gardening_last_location');
                    if (cached) {
                        try {
                            const loc = JSON.parse(cached);
                            if (loc.type === 'coords' && loc.lat && loc.lon) {
                                const latNum = typeof loc.lat === 'string' ? parseFloat(loc.lat) : loc.lat;
                                const lonNum = typeof loc.lon === 'string' ? parseFloat(loc.lon) : loc.lon;
                                showClimateZone(latNum, lonNum);
                                return;
                            }
                        } catch (e) {}
                    }
                    renderClimateZoneUI();
                });
            }
        }

        // Helper: Convert temperature and precipitation
        function convertTemp(val, unit) {
            if (unit === 'F') return Math.round(val * 9/5 + 32);
            return Math.round(val);
        }
        function convertPrecip(val, unit) {
            if (unit === 'in') return (val / 25.4).toFixed(2);
            return val;
        }
        function getTempUnitSymbol() {
            return tempUnitSelect.value === 'F' ? '¬∞F' : '¬∞C';
        }
        function getPrecipUnitSymbol() {
            return precipUnitSelect.value === 'in' ? 'in' : 'mm';
        }

        // Function to render calendar content
        function renderCalendar(month, searchTerm = '') {
            // Clear content
            calendarContent.innerHTML = '';
            
            // Check if month has data
            if (!calendarData[month]) {
                calendarContent.innerHTML = '<div class="no-results">No data available for selected month.</div>';
                return;
            }
            
            // Show categories
            const categories = Object.keys(calendarData[month]);
            
            // Filter for search
            let hasResults = false;
            let delay = 0;
            
            categories.forEach(category => {
                const items = calendarData[month][category];
                let filteredItems = items;
                
                // Apply filter if search term exists
                if (searchTerm) {
                    filteredItems = items.filter(item => 
                        item.toLowerCase().includes(searchTerm.toLowerCase())
                    );
                }
                
                // Don't show category if no results after filtering
                if (filteredItems.length === 0 && searchTerm) {
                    return;
                }
                
                hasResults = true;
                
                // Create category card
                const categoryCard = document.createElement('div');
                const categoryClass = category === 'garden_tasks' ? 'category-card garden-tasks-card' : 'category-card';
                categoryCard.className = `${categoryClass} fade-in`;
                categoryCard.style.animationDelay = `${delay}ms`;
                delay += 100;
                
                // Icon and title
                const isTaskCategory = category === 'garden_tasks';
                
                categoryCard.innerHTML = `
                    <div class="category-header">
                        <div class="category-icon">${categoryIcons[category] || 'üåø'}</div>
                        <h2 class="category-title">${categoryNames[category] || category}</h2>
                    </div>
                    <ul class="plant-list">
                        ${filteredItems.map(item => `
                            <li class="${isTaskCategory ? 'task-item' : 'plant-item'}" data-item-id="${encodeURIComponent(item)}">
                                <label class="item-label">
                                    <input type="checkbox" class="item-checkbox" 
                                        ${isItemSelected(month, category, item) ? 'checked' : ''}>
                                    <span class="item-text">${searchTerm ? highlightText(item, searchTerm) : item}</span>
                                </label>
                            </li>
                        `).join('')}
                    </ul>
                `;

                // Add event listeners for checkboxes
                categoryCard.querySelectorAll('.item-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const item = decodeURIComponent(e.target.closest('li').dataset.itemId);
                        toggleItemSelection(month, category, item, e.target.checked);
                    });
                });
                
                calendarContent.appendChild(categoryCard);
            });
            
            // If no results found
            if (!hasResults) {
                calendarContent.innerHTML = '<div class="no-results">No results found for your search.</div>';
            }
        }

        // Search function
        function searchCalendar() {
            const searchTerm = searchBox.value.trim();
            renderCalendar(activeMonth, searchTerm);
        }

        // Text highlighting function
        function highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            
            const regex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        // Escape special characters in regular expression
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Listen for month button clicks
        monthButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons
                monthButtons.forEach(btn => btn.classList.remove('active'));
                
                // Add active class to clicked button
                button.classList.add('active');
                
                // Update active month
                activeMonth = button.dataset.month;
                
                // Show calendar
                searchBox.value = ''; // Reset search
                renderCalendar(activeMonth);
            });
        });

        // Listen for search input
        searchBox.addEventListener('input', searchCalendar);

        // Initial calendar display
        renderCalendar(activeMonth);

        // Weather/location handling
        const locationInput = document.getElementById('locationInput');
        const useMyLocationBtn = document.getElementById('useMyLocationBtn');
        const weatherPlaceholder = document.getElementById('weatherPlaceholder');

        // Helper: Display error with optional retry
        function displayLocationError(msg, retryType = null) {
            let retryBtn = '';
            if (retryType === 'geocode') {
                retryBtn = '<button id="retryGeocodeBtn" style="margin-left:12px;">Retry</button>';
            } else if (retryType === 'weather') {
                retryBtn = '<button id="retryWeatherBtn" style="margin-left:12px;">Retry</button>';
            }
            weatherPlaceholder.innerHTML = `<div role="alert" style="color: #b71c1c;">${msg}${retryBtn}</div>`;
            if (retryType === 'geocode') {
                const btn = document.getElementById('retryGeocodeBtn');
                if (btn) btn.onclick = () => {
                    if (lastGeocodeQuery) geocodeLocation(lastGeocodeQuery, true);
                };
            } else if (retryType === 'weather') {
                const btn = document.getElementById('retryWeatherBtn');
                if (btn) btn.onclick = () => {
                    if (lastWeatherCoords) fetchWeatherData(lastWeatherCoords.lat, lastWeatherCoords.lon, true);
                };
            }
        }

        // Helper: Display location and coordinates, then fetch and display weather
        function displayLocationInfo(name, lat, lon, admin1, admin2, country) {
            let locationParts = [];
            if (name) locationParts.push(name);
            if (admin2) locationParts.push(admin2);
            if (admin1) locationParts.push(admin1);
            if (country) locationParts.push(country);
            const locationString = locationParts.join(', ');
            weatherPlaceholder.innerHTML =
                `<div class="weather-location-info"><strong>Location:</strong> ${locationString}<br><br>` +
                `<span style="font-size:0.97em;color:#666;">Latitude: ${lat}, Longitude: ${lon}</span></div>` +
                `<div id="weatherDataSection">Loading weather data...</div>`;
            lastWeatherCoords = { lat, lon };
            lastWeatherAction = 'weather';
            fetchWeatherData(lat, lon);
            showClimateZone(lat, lon);
        }

        // Weather code to icon, text, and color (Open-Meteo codes)
        function weatherCodeToIconTextColor(code) {
            // Weather type to color mapping
            const typeColors = {
                sun:   { bg: '#fffde7', color: '#fbc02d' },
                cloud: { bg: '#eceff1', color: '#607d8b' },
                rain:  { bg: '#e3f2fd', color: '#1976d2' },
                snow:  { bg: '#f3e5f5', color: '#7e57c2' },
                storm: { bg: '#ffe0b2', color: '#e65100' },
                fog:   { bg: '#f5f5f5', color: '#757575' },
                unknown: { bg: '#eeeeee', color: '#888' }
            };
            // Map weather code to icon, text, and type
            const map = {
                0:  {icon: '‚òÄÔ∏è', text: 'Clear sky', type: 'sun'},
                1:  {icon: 'üå§Ô∏è', text: 'Mainly clear', type: 'sun'},
                2:  {icon: '‚õÖ', text: 'Partly cloudy', type: 'cloud'},
                3:  {icon: '‚òÅÔ∏è', text: 'Overcast', type: 'cloud'},
                45: {icon: 'üå´Ô∏è', text: 'Fog', type: 'fog'},
                48: {icon: 'üå´Ô∏è', text: 'Rime fog', type: 'fog'},
                51: {icon: 'üå¶Ô∏è', text: 'Light drizzle', type: 'rain'},
                53: {icon: 'üå¶Ô∏è', text: 'Drizzle', type: 'rain'},
                55: {icon: 'üå¶Ô∏è', text: 'Dense drizzle', type: 'rain'},
                56: {icon: 'üåßÔ∏è', text: 'Freezing light drizzle', type: 'rain'},
                57: {icon: 'üåßÔ∏è', text: 'Freezing drizzle', type: 'rain'},
                61: {icon: 'üå¶Ô∏è', text: 'Slight rain', type: 'rain'},
                63: {icon: 'üåßÔ∏è', text: 'Rain', type: 'rain'},
                65: {icon: 'üåßÔ∏è', text: 'Heavy rain', type: 'rain'},
                66: {icon: 'üåßÔ∏è', text: 'Freezing light rain', type: 'rain'},
                67: {icon: 'üåßÔ∏è', text: 'Freezing rain', type: 'rain'},
                71: {icon: 'üå®Ô∏è', text: 'Slight snow fall', type: 'snow'},
                73: {icon: 'üå®Ô∏è', text: 'Snow fall', type: 'snow'},
                75: {icon: '‚ùÑÔ∏è', text: 'Heavy snow fall', type: 'snow'},
                77: {icon: '‚ùÑÔ∏è', text: 'Snow grains', type: 'snow'},
                80: {icon: 'üå¶Ô∏è', text: 'Slight rain showers', type: 'rain'},
                81: {icon: 'üåßÔ∏è', text: 'Rain showers', type: 'rain'},
                82: {icon: 'üåßÔ∏è', text: 'Violent rain showers', type: 'rain'},
                85: {icon: 'üå®Ô∏è', text: 'Slight snow showers', type: 'snow'},
                86: {icon: 'üå®Ô∏è', text: 'Snow showers', type: 'snow'},
                95: {icon: '‚õàÔ∏è', text: 'Thunderstorm', type: 'storm'},
                96: {icon: '‚õàÔ∏è', text: 'Thunderstorm w/ hail', type: 'storm'},
                99: {icon: '‚õàÔ∏è', text: 'Thunderstorm w/ heavy hail', type: 'storm'}
            };
            const entry = map[code] || {icon: '‚ùì', text: 'Unknown', type: 'unknown'};
            const color = typeColors[entry.type] || typeColors.unknown;
            return { ...entry, ...color };
        }

        // Fetch weather data from Open-Meteo
        async function fetchWeatherData(lat, lon, isRetry = false) {
            lastWeatherCoords = { lat, lon };
            lastWeatherAction = 'weather';
            lastWeatherLat = lat;
            lastWeatherLon = lon;
            const weatherSection = document.getElementById('weatherDataSection');
            if (!weatherSection) return;
            weatherSection.textContent = 'Loading weather data...';
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weathercode&hourly=temperature_2m,precipitation,windspeed_10m&forecast_days=16&timezone=auto`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Weather service error');
                const data = await response.json();
                lastWeatherData = data;
                if (!data.current_weather || !data.daily || !data.hourly) {
                    weatherSection.innerHTML = '<div role="alert" style="color: #b71c1c;">Weather data not available for this location.</div>';
                    return;
                }
                renderWeatherData(data);
            } catch (e) {
                if (weatherSection) {
                    weatherSection.innerHTML = '<div role="alert" style="color: #b71c1c;">Could not fetch weather data. <button id="retryWeatherBtn" style="margin-left:12px;">Retry</button></div>';
                    const btn = document.getElementById('retryWeatherBtn');
                    if (btn) btn.onclick = () => {
                        if (lastWeatherCoords) fetchWeatherData(lastWeatherCoords.lat, lastWeatherCoords.lon, true);
                    };
                }
            }
        }

        // Render weather data in selected units
        function renderWeatherData(data) {
            const weatherSection = document.getElementById('weatherDataSection');
            if (!weatherSection) return;
            const tempUnit = tempUnitSelect.value;
            const precipUnit = precipUnitSelect.value;
            // Display current weather
            const currentIconTextColor = weatherCodeToIconTextColor(data.current_weather.weathercode);
            let html = `<div class="weather-current"><strong>Current weather:</strong> <span style="display:inline-block;background:${currentIconTextColor.bg};border-radius:50%;padding:6px 10px;font-size:1.4em;color:${currentIconTextColor.color};margin-right:6px;">${currentIconTextColor.icon}</span> ${currentIconTextColor.text}, ${convertTemp(data.current_weather.temperature, tempUnit)}${getTempUnitSymbol()}, Wind: ${data.current_weather.windspeed} km/h</div>`;
            // Prepare hourly data grouped by day
            const hourlyByDay = groupHourlyByDay(data.hourly, data.daily.time);
            const hourlyPrecipByDay = groupHourlyByDay({ time: data.hourly.time, temperature_2m: data.hourly.precipitation }, data.daily.time);
            const hourlyWindByDay = groupHourlyByDay({ time: data.hourly.time, temperature_2m: data.hourly.windspeed_10m }, data.daily.time);
            // Display forecast table
            html += `<div style="margin-top:10px;"><strong>16-day forecast:</strong></div>`;
            html += `<table class="weather-forecast-table"><caption class='visually-hidden'>16-day weather forecast for selected location</caption><thead><tr><th scope='col'>Date</th><th scope='col'>Night Min</th><th scope='col'>Night Max</th><th scope='col'>Day Min</th><th scope='col'>Day Max</th><th scope='col'>Precip.</th><th scope='col'>Weather</th><th scope='col'>Temp Trend</th></tr></thead><tbody>`;
            for (let i = 0; i < data.daily.time.length; i++) {
                const { nightMin, nightMax, dayMin, dayMax } = calcNightDayMinMax(hourlyByDay[i]);
                const weatherIconTextColor = weatherCodeToIconTextColor(data.daily.weathercode[i]);
                
                // Color-code the temperature cells
                function getTempHtml(tempValue) {
                    if (tempValue === null) return '-';
                    const temp = convertTemp(tempValue, tempUnit);
                    const tempColor = getTemperatureColor(temp, tempUnit);
                    
                    // Calculate contrasting text color (black or white) based on background color
                    // Convert hex color to RGB to calculate luminance
                    const hexToRgb = (hex) => {
                        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        const fullHex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHex);
                        return result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : {r: 0, g: 0, b: 0};
                    };
                    
                    // Calculate relative luminance for accessibility contrast
                    const rgb = hexToRgb(tempColor);
                    
                    // Use the original color but with reduced opacity for a softer look
                    const bgColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.25)`;
                    const textColor = '#333333';
                    const borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.5)`;
                    
                    return `<span style="display:inline-block;background-color:${bgColor};color:${textColor};padding:2px 6px;border-radius:4px;font-weight:500;border:1px solid ${borderColor};">${temp}${getTempUnitSymbol()}</span>`;
                }
                
                html += `<tr>
                    <td>${data.daily.time[i]}</td>
                    <td>${getTempHtml(nightMin)}</td>
                    <td>${getTempHtml(nightMax)}</td>
                    <td>${getTempHtml(dayMin)}</td>
                    <td>${getTempHtml(dayMax)}</td>
                    <td>${convertPrecip(data.daily.precipitation_sum[i], precipUnit)} ${getPrecipUnitSymbol()}</td>
                    <td><span style='display:inline-block;background:${weatherIconTextColor.bg};border-radius:50%;padding:7px 12px;font-size:1.5em;color:${weatherIconTextColor.color};margin-bottom:2px;'>${weatherIconTextColor.icon}</span><br><span style='color:${weatherIconTextColor.color};font-size:0.93em;'>${weatherIconTextColor.text}</span></td>
                    <td>${renderSparkline(hourlyByDay[i], i, tempUnit)}</td>
                </tr>`;
            }
            html += `</tbody></table>`;
            weatherSection.innerHTML = html;
            // Add event listeners for sparklines
            addSparklineListeners(hourlyByDay, data.daily.time, hourlyPrecipByDay, hourlyWindByDay, tempUnit, precipUnit);
        }

        // Calculate night and day min/max for a day's hourly temps
        function calcNightDayMinMax(temps) {
            if (!temps || temps.length !== 24) return { nightMin: null, nightMax: null, dayMin: null, dayMax: null };
            // Night: 21:00‚Äì23:00 (21,22,23) and 00:00‚Äì05:00 (0,1,2,3,4,5)
            const nightHours = [21,22,23,0,1,2,3,4,5];
            const dayHours = [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];
            const nightTemps = nightHours.map(h => temps[h]).filter(t => t !== undefined);
            const dayTemps = dayHours.map(h => temps[h]).filter(t => t !== undefined);
            return {
                nightMin: nightTemps.length ? Math.round(Math.min(...nightTemps)) : null,
                nightMax: nightTemps.length ? Math.round(Math.max(...nightTemps)) : null,
                dayMin: dayTemps.length ? Math.round(Math.min(...dayTemps)) : null,
                dayMax: dayTemps.length ? Math.round(Math.max(...dayTemps)) : null
            };
        }

        // Group hourly temperature data by day
        function groupHourlyByDay(hourly, dailyDates) {
            const result = [];
            const hours = hourly.time;
            const temps = hourly.temperature_2m;
            let dayIndex = 0;
            let currentDay = dailyDates[dayIndex];
            let dayTemps = [];
            for (let i = 0; i < hours.length; i++) {
                if (hours[i].startsWith(currentDay)) {
                    dayTemps.push(temps[i]);
                } else {
                    result.push(dayTemps);
                    dayTemps = [];
                    dayIndex++;
                    currentDay = dailyDates[dayIndex];
                    if (!currentDay) break;
                    if (hours[i].startsWith(currentDay)) {
                        dayTemps.push(temps[i]);
                    }
                }
            }
            if (dayTemps.length) result.push(dayTemps);
            return result;
        }

        // Shared temperature color mapping function
        function getTemperatureColor(temp, tempUnit) {
            // Define more granular temperature steps
            const temperatureSteps = tempUnit === 'F' ? [
                { threshold: 14, color: '#0d47a1' },   // Very cold (deep blue)
                { threshold: 23, color: '#1565c0' },   // Freezing (deep blue-mid blue)
                { threshold: 32, color: '#1976d2' },   // Freezing point (mid blue)
                { threshold: 41, color: '#1e88e5' },   // Cold (blue)
                { threshold: 50, color: '#42a5f5' },   // Cool (light blue)
                { threshold: 59, color: '#64b5f6' },   // Cool-mild (pale blue)
                { threshold: 64, color: '#81c784' },   // Mild (light green)
                { threshold: 68, color: '#4caf50' },   // Mild-comfortable (medium green)
                { threshold: 73, color: '#7cb342' },   // Comfortable (green-yellow)
                { threshold: 77, color: '#9e9d24' },   // Warm (yellow-green)
                { threshold: 82, color: '#ffb74d' },   // Warm-hot (light orange)
                { threshold: 86, color: '#ff9800' },   // Hot (orange)
                { threshold: 91, color: '#f57c00' },   // Very hot (dark orange)
                { threshold: 95, color: '#e64a19' },   // Extremely hot (orange-red)
                { threshold: 100, color: '#d32f2f' },  // Dangerous heat (red)
                { threshold: Infinity, color: '#b71c1c' } // Extreme heat (deep red)
            ] : [
                { threshold: -20, color: '#0d47a1' },  // Extreme cold (deep blue)
                { threshold: -15, color: '#1565c0' },  // Very cold (deep blue-mid blue)
                { threshold: -10, color: '#1976d2' },  // Very cold (mid blue)
                { threshold: -5, color: '#1e88e5' },   // Cold (blue)
                { threshold: 0, color: '#42a5f5' },    // Freezing (light blue)
                { threshold: 5, color: '#64b5f6' },    // Cool (pale blue)
                { threshold: 10, color: '#81c784' },   // Cool-mild (light green)
                { threshold: 15, color: '#4caf50' },   // Mild (medium green)
                { threshold: 20, color: '#7cb342' },   // Comfortable (green-yellow)
                { threshold: 23, color: '#9e9d24' },   // Warm (yellow-green)
                { threshold: 26, color: '#ffb74d' },   // Warm-hot (light orange)
                { threshold: 30, color: '#ff9800' },   // Hot (orange)
                { threshold: 33, color: '#f57c00' },   // Very hot (dark orange)
                { threshold: 36, color: '#e64a19' },   // Extremely hot (orange-red)
                { threshold: 40, color: '#d32f2f' },   // Dangerous heat (red)
                { threshold: Infinity, color: '#b71c1c' } // Extreme heat (deep red)
            ];
            
            // Find the appropriate color based on temperature
            for (const step of temperatureSteps) {
                if (temp <= step.threshold) {
                    return step.color;
                }
            }
            return '#b71c1c'; // Fallback to deepest red
        }

        // Render a mini SVG sparkline for a day's temperatures
        function renderSparkline(temps, dayIndex, tempUnit) {
            if (!temps || temps.length === 0) return '';
            const w = 60, h = 40;
            // Convert all temps for sparkline
            const convertedTemps = temps.map(t => convertTemp(t, tempUnit));
            
            // Use absolute temperature ranges for consistent coloring
            // -10¬∞C (14¬∞F) to 40¬∞C (104¬∞F) is a reasonable range for most weather
            const absMinTemp = tempUnit === 'F' ? 14 : -10;
            const absMaxTemp = tempUnit === 'F' ? 104 : 40;
            
            // Use local min/max for the height calculations only
            const min = Math.min(...convertedTemps);
            const max = Math.max(...convertedTemps);
            const range = max - min || 1;
            
            // Create a smooth curve using cubic bezier curves
            let path = '';
            const allPoints = [];
            let pathSegments = [];
            
            convertedTemps.forEach((t, i) => {
                const x = (i / (convertedTemps.length - 1)) * (w - 2) + 1;
                const y = h - 2 - ((t - min) / range) * (h - 4);
                allPoints.push({ x, y, temp: t });
            });
            
            // Build smooth path using cubic bezier curves
            if (allPoints.length > 0) {
                path = `M ${allPoints[0].x.toFixed(1)},${allPoints[0].y.toFixed(1)}`;
                
                for (let i = 0; i < allPoints.length - 1; i++) {
                    const current = allPoints[i];
                    const next = allPoints[i + 1];
                    
                    // Calculate control points for smooth curve
                    const cpx1 = current.x + (next.x - current.x) / 3;
                    const cpy1 = current.y;
                    const cpx2 = current.x + 2 * (next.x - current.x) / 3;
                    const cpy2 = next.y;
                    
                    const segment = `C${cpx1.toFixed(1)},${cpy1.toFixed(1)} ${cpx2.toFixed(1)},${cpy2.toFixed(1)} ${next.x.toFixed(1)},${next.y.toFixed(1)}`;
                    path += ` ${segment}`;
                    
                    // Store segment with average temperature for coloring
                    const avgTemp = (current.temp + next.temp) / 2;
                    pathSegments.push({
                        segment: segment,
                        temp: avgTemp,
                        startX: current.x,
                        endX: next.x
                    });
                }
            }
            
            // Reference lines for 0 and 20 (in selected unit)
            const y0 = h - 2 - ((convertTemp(0, tempUnit) - min) / range) * (h - 4);
            const y20 = h - 2 - ((convertTemp(20, tempUnit) - min) / range) * (h - 4);
            
            // Create multiple path elements with different colors based on temperature
            let coloredPaths = '';
            
            if (allPoints.length > 0) {
                coloredPaths += `<path d="M ${allPoints[0].x.toFixed(1)},${allPoints[0].y.toFixed(1)}`;
                
                pathSegments.forEach((segment, i) => {
                    const color = getTemperatureColor(segment.temp, tempUnit);
                    coloredPaths += `<path d="M ${segment.startX.toFixed(1)},${allPoints[i].y.toFixed(1)} ${segment.segment}" 
                        fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />`;
                });
            }
            
            return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="vertical-align:middle;cursor:pointer;" data-day-index="${dayIndex}">
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y0.toFixed(1)} ${w},${y0.toFixed(1)}" opacity="0.5" />
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y20.toFixed(1)} ${w},${y20.toFixed(1)}" opacity="0.5" />
                ${coloredPaths}
            </svg>`;
        }

        // Render a larger SVG chart for modal
        function renderLargeTempChart(temps, tempUnit) {
            if (!temps || temps.length === 0) return '';
            const w = 340, h = 100;
            // Convert all temps for chart
            const convertedTemps = temps.map(t => convertTemp(t, tempUnit));
            
            // Use absolute temperature ranges for consistent coloring
            // -10¬∞C (14¬∞F) to 40¬∞C (104¬∞F) is a reasonable range for most weather
            const absMinTemp = tempUnit === 'F' ? 14 : -10;
            const absMaxTemp = tempUnit === 'F' ? 104 : 40;
            
            // Use local min/max for the height calculations only
            const min = Math.min(...convertedTemps);
            const max = Math.max(...convertedTemps);
            const range = max - min || 1;
            
            // Create a smooth curve using cubic bezier curves
            let path = '';
            const allPoints = [];
            let pathSegments = [];
            
            convertedTemps.forEach((t, i) => {
                const x = (i / (convertedTemps.length - 1)) * (w - 2) + 1;
                const y = h - 20 - ((t - min) / range) * (h - 40);
                allPoints.push({ x, y, temp: t });
            });
            
            // Build smooth path using cubic bezier curves
            if (allPoints.length > 0) {
                path = `M ${allPoints[0].x.toFixed(1)},${allPoints[0].y.toFixed(1)}`;
                
                for (let i = 0; i < allPoints.length - 1; i++) {
                    const current = allPoints[i];
                    const next = allPoints[i + 1];
                    
                    // Calculate control points for smooth curve
                    const cpx1 = current.x + (next.x - current.x) / 3;
                    const cpy1 = current.y;
                    const cpx2 = current.x + 2 * (next.x - current.x) / 3;
                    const cpy2 = next.y;
                    
                    const segment = `C${cpx1.toFixed(1)},${cpy1.toFixed(1)} ${cpx2.toFixed(1)},${cpy2.toFixed(1)} ${next.x.toFixed(1)},${next.y.toFixed(1)}`;
                    path += ` ${segment}`;
                    
                    // Store segment with average temperature for coloring
                    const avgTemp = (current.temp + next.temp) / 2;
                    pathSegments.push({
                        segment: segment,
                        temp: avgTemp,
                        startX: current.x,
                        endX: next.x
                    });
                }
            }
            
            // Reference lines for 0 and 20 (in selected unit)
            const y0 = h - 20 - ((convertTemp(0, tempUnit) - min) / range) * (h - 40);
            const y20 = h - 20 - ((convertTemp(20, tempUnit) - min) / range) * (h - 40);
            const minLabel = min + getTempUnitSymbol();
            const maxLabel = max + getTempUnitSymbol();
            
            // Create multiple path elements with different colors based on temperature
            let coloredPaths = '';
            
            if (allPoints.length > 0) {
                coloredPaths += `<path d="M ${allPoints[0].x.toFixed(1)},${allPoints[0].y.toFixed(1)}`;
                
                pathSegments.forEach((segment, i) => {
                    const color = getTemperatureColor(segment.temp, tempUnit);
                    coloredPaths += `<path d="M ${segment.startX.toFixed(1)},${allPoints[i].y.toFixed(1)} ${segment.segment}" 
                        fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />`;
                });
            }
            
            return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y0.toFixed(1)} ${w},${y0.toFixed(1)}" opacity="0.5" />
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y20.toFixed(1)} ${w},${y20.toFixed(1)}" opacity="0.5" />
                ${coloredPaths}
                <text x="2" y="${h - 22}" font-size="11" fill="#888">${minLabel}</text>
                <text x="2" y="18" font-size="11" fill="#888">${maxLabel}</text>
            </svg>`;
        }

        // Show modal with detailed chart and hourly temps
        function showWeatherModal(dayIndex, date, temps, precips, winds) {
            // Track weather detail view in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'view_weather_details', {
                    'date': date,
                    'day_index': dayIndex
                });
            }
            
            // Remove any existing modal
            const oldModal = document.getElementById('weatherModalOverlay');
            if (oldModal) oldModal.remove();
            // Build hourly table
            const tempUnit = tempUnitSelect.value;
            const precipUnit = precipUnitSelect.value;
            let hourlyTable = '<table class="weather-modal-hourly-table"><thead><tr><th>Hour</th><th>Temp (' + getTempUnitSymbol() + ')</th><th>Precip. (' + getPrecipUnitSymbol() + ')</th><th>Wind (km/h)</th></tr></thead><tbody>';
            for (let h = 0; h < temps.length; h++) {
                // Color-code the temperature cell
                const temp = convertTemp(temps[h], tempUnit);
                const tempColor = getTemperatureColor(temp, tempUnit);
                
                // Calculate contrasting text color (black or white) based on background color
                const hexToRgb = (hex) => {
                    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                    const fullHex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHex);
                    return result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : {r: 0, g: 0, b: 0};
                };
                
                // Calculate relative luminance for accessibility contrast
                const rgb = hexToRgb(tempColor);
                
                // Use the original color but with reduced opacity for a softer look
                const bgColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.25)`;
                const textColor = '#333333';
                const borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.5)`;
                
                const tempHtml = `<span style="display:inline-block;background-color:${bgColor};color:${textColor};padding:2px 6px;border-radius:4px;font-weight:500;width:100%;border:1px solid ${borderColor};">${temp}${getTempUnitSymbol()}</span>`;
                
                hourlyTable += `<tr>
                    <td>${h}:00</td>
                    <td>${tempHtml}</td>
                    <td>${precips && precips[h] !== undefined ? convertPrecip(precips[h], precipUnit) : '-'}</td>
                    <td>${winds && winds[h] !== undefined ? Math.round(winds[h]) : '-'}</td>
                </tr>`;
            }
            hourlyTable += '</tbody></table>';
            // Modal HTML
            const modalHtml = `
                <div class="weather-modal-overlay" id="weatherModalOverlay" tabindex="-1">
                    <div class="weather-modal" role="dialog" aria-modal="true" aria-labelledby="weatherModalTitle">
                        <button class="weather-modal-close" id="weatherModalCloseBtn" aria-label="Close weather details">&times;</button>
                        <div class="weather-modal-title" id="weatherModalTitle">Hourly Weather for ${date}</div>
                        <div class="weather-modal-chart">${renderLargeTempChart(temps, tempUnit)}</div>
                        ${hourlyTable}
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            // Focus management
            const closeBtn = document.getElementById('weatherModalCloseBtn');
            if (closeBtn) closeBtn.focus();
            // Trap focus inside modal
            const modalOverlay = document.getElementById('weatherModalOverlay');
            const focusableSelectors = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            const modal = modalOverlay.querySelector('.weather-modal');
            const focusableEls = modal.querySelectorAll(focusableSelectors);
            const firstFocusable = focusableEls[0];
            const lastFocusable = focusableEls[focusableEls.length - 1];
            modalOverlay.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    if (focusableEls.length === 0) return;
                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            e.preventDefault();
                            lastFocusable.focus();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            e.preventDefault();
                            firstFocusable.focus();
                        }
                    }
                } else if (e.key === 'Escape') {
                    modalOverlay.remove();
                }
            });
            // Close logic
            closeBtn.onclick = () => {
                modalOverlay.remove();
            };
            modalOverlay.onclick = (e) => {
                if (e.target.id === 'weatherModalOverlay') {
                    modalOverlay.remove();
                }
            };
        }

        // Add event delegation for sparkline clicks after weather table is rendered
        function addSparklineListeners(hourlyByDay, dailyDates, hourlyPrecipByDay, hourlyWindByDay, tempUnit, precipUnit) {
            const table = document.querySelector('.weather-forecast-table');
            if (!table) return;
            table.addEventListener('click', function(e) {
                const svg = e.target.closest('svg[data-day-index]');
                if (svg) {
                    const dayIndex = parseInt(svg.getAttribute('data-day-index'));
                    if (!isNaN(dayIndex) && hourlyByDay[dayIndex]) {
                        showWeatherModal(
                            dayIndex,
                            dailyDates[dayIndex],
                            hourlyByDay[dayIndex],
                            hourlyPrecipByDay ? hourlyPrecipByDay[dayIndex] : null,
                            hourlyWindByDay ? hourlyWindByDay[dayIndex] : null
                        );
                    }
                }
            });
        }

        // On page load, check for cached location
        window.addEventListener('DOMContentLoaded', () => {
            const cached = localStorage.getItem('gardening_last_location');
            if (cached) {
                try {
                    const loc = JSON.parse(cached);
                    if (loc.type === 'query' && loc.value) {
                        locationInput.value = loc.value;
                        // Show the clear button since we have text in the input
                        clearLocationBtn.style.display = 'block';
                        geocodeLocation(loc.value);
                    } else if (loc.type === 'coords' && loc.lat && loc.lon) {
                        // Clear the input when using coordinates
                        locationInput.value = '';
                        clearLocationBtn.style.display = 'none';
                        displayLocationInfo('Your location', loc.lat, loc.lon, '', '', '');
                    }
                } catch (e) {}
            }
        });
        
        // Handle clear button logic and input events
        const clearLocationBtn = document.getElementById('clearLocationBtn');
        
        // Show/hide clear button based on input content
        locationInput.addEventListener('input', function() {
            clearLocationBtn.style.display = this.value ? 'block' : 'none';
        });
        
        // Clear input when clear button is clicked
        clearLocationBtn.addEventListener('click', function() {
            locationInput.value = '';
            locationInput.focus();
            clearLocationBtn.style.display = 'none';
        });
        
        // We now handle the clear button visibility during page load in the DOMContentLoaded event
        
        // We're now using a single placeholder format for consistency

        // Geocoding API call
        async function geocodeLocation(query, isRetry = false) {
            // Track location search in Google Analytics
            if (typeof gtag === 'function' && !isRetry) {
                gtag('event', 'search_location', {
                    'search_term': query
                });
            }
            
            lastGeocodeQuery = query;
            lastWeatherAction = 'geocode';
            weatherPlaceholder.textContent = 'Looking up location...';
            // Cache the query
            localStorage.setItem('gardening_last_location', JSON.stringify({ type: 'query', value: query }));
            try {
                const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Geocoding service error');
                const data = await response.json();
                if (!data.results || data.results.length === 0) {
                    displayLocationError('Location not found. Please try a different name or postal code.', 'geocode');
                    return;
                }
                const result = data.results[0];
                displayLocationInfo(
                    result.name,
                    result.latitude,
                    result.longitude,
                    result.admin1,
                    result.admin2,
                    result.country
                );
            } catch (e) {
                displayLocationError('Could not resolve location. Please check your input and try again.', 'geocode');
            }
        }

        // Handle location input (Enter or blur)
        locationInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const query = locationInput.value.trim();
                if (query) geocodeLocation(query);
            }
        });
        locationInput.addEventListener('blur', function() {
            const query = locationInput.value.trim();
            if (query) geocodeLocation(query);
        });

        // Handle 'Use my location' button
        useMyLocationBtn.addEventListener('click', function() {
            // Clear the input field when using geolocation
            locationInput.value = '';
            
            weatherPlaceholder.textContent = 'Getting your location...';
            if (!navigator.geolocation) {
                displayLocationError('Geolocation is not supported by your browser.', 'geocode');
                return;
            }
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    const lat = pos.coords.latitude.toFixed(5);
                    const lon = pos.coords.longitude.toFixed(5);
                    // Cache the coordinates
                    localStorage.setItem('gardening_last_location', JSON.stringify({ type: 'coords', lat, lon }));
                    displayLocationInfo('Your location', lat, lon, '', '', '');
                },
                (err) => {
                    displayLocationError('Could not get your location. Please allow location access or enter a place name.', 'geocode');
                }
            );
        });

        // Unit preference logic
        const tempUnitSelect = document.getElementById('tempUnitSelect');
        const precipUnitSelect = document.getElementById('precipUnitSelect');
        // Load preferences from localStorage
        function loadUnitPrefs() {
            const temp = localStorage.getItem('gardening_temp_unit');
            const precip = localStorage.getItem('gardening_precip_unit');
            if (temp && (temp === 'C' || temp === 'F')) tempUnitSelect.value = temp;
            if (precip && (precip === 'mm' || precip === 'in')) precipUnitSelect.value = precip;
        }
        // Save preferences to localStorage
        tempUnitSelect.addEventListener('change', () => {
            localStorage.setItem('gardening_temp_unit', tempUnitSelect.value);
            // Track event in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'change_preference', {
                    'preference_type': 'temperature_unit',
                    'value': tempUnitSelect.value
                });
            }
            if (lastWeatherData) renderWeatherData(lastWeatherData);
        });
        precipUnitSelect.addEventListener('change', () => {
            localStorage.setItem('gardening_precip_unit', precipUnitSelect.value);
            // Track event in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'change_preference', {
                    'preference_type': 'precipitation_unit',
                    'value': precipUnitSelect.value
                });
            }
            if (lastWeatherData) renderWeatherData(lastWeatherData);
        });
        // On page load, set unit preferences
        window.addEventListener('DOMContentLoaded', loadUnitPrefs);

        // Prompt Generator Logic
        const generatePromptBtn = document.getElementById('generatePromptBtn');
        const copyPromptBtn = document.getElementById('copyPromptBtn');
        const customNotes = document.getElementById('customNotes');
        const generatedPrompt = document.getElementById('generatedPrompt');
        const promptGeneratorModal = document.getElementById('promptGeneratorModal');
        const closePromptGeneratorBtn = document.getElementById('closePromptGeneratorBtn');
        const aiAdviceBtn = document.getElementById('aiAdviceBtn');
        const includeCalendar = document.getElementById('includeCalendar');
        const includeRelevantPlantsOnly = document.getElementById('includeRelevantPlantsOnly');

        // Modal handling
        function openPromptGenerator() {
            promptGeneratorModal.style.display = 'flex';
            customNotes.focus();
            // Store active element to restore focus later
            openPromptGenerator.previousActiveElement = document.activeElement;
        }

        function closePromptGenerator() {
            promptGeneratorModal.style.display = 'none';
            // Reset the generated prompt
            generatedPrompt.textContent = 'Click "Generate Prompt" to create a customized gardening prompt based on your location, weather, and calendar data.';
            // Hide AI assistants section
            document.getElementById('promptDestinationSection').style.display = 'none';
            // Clear custom notes
            customNotes.value = '';
            // Reset checkboxes to default state
            includeCalendar.checked = true;
            includeRelevantPlantsOnly.checked = true;
            // Restore focus
            if (openPromptGenerator.previousActiveElement) {
                openPromptGenerator.previousActiveElement.focus();
            }
        }

        // Add event listener for the AI advice button
        aiAdviceBtn.addEventListener('click', openPromptGenerator);

        // Close modal on escape or clicking outside
        promptGeneratorModal.addEventListener('click', (e) => {
            if (e.target === promptGeneratorModal) {
                closePromptGenerator();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && promptGeneratorModal.style.display === 'flex') {
                closePromptGenerator();
            }
        });

        closePromptGeneratorBtn.addEventListener('click', closePromptGenerator);

        function isPlantSuitableForWeather(plant, weatherData) {
            // Get temperature range for next 7 days
            const next7Days = weatherData.daily.temperature_2m_max.slice(0, 7);
            const maxTemp = Math.max(...next7Days);
            const minTemp = Math.min(...weatherData.daily.temperature_2m_min.slice(0, 7));
            const avgPrecip = weatherData.daily.precipitation_sum.slice(0, 7).reduce((a, b) => a + b, 0) / 7;

            // Basic suitability rules (these could be made more sophisticated)
            const coldSensitive = ['tomato', 'pepper', 'eggplant', 'cucumber', 'zucchini', 'pumpkin', 'melon', 'basil'];
            const heatSensitive = ['lettuce', 'spinach', 'arugula', 'peas'];
            const moistureSensitive = ['tomato', 'rosemary', 'thyme', 'sage'];

            const plantLower = plant.toLowerCase();

            // Check temperature suitability
            if (coldSensitive.some(p => plantLower.includes(p)) && minTemp < 10) return false;
            if (heatSensitive.some(p => plantLower.includes(p)) && maxTemp > 30) return false;
            
            // Check moisture suitability
            if (moistureSensitive.some(p => plantLower.includes(p)) && avgPrecip > 10) return false;

            return true;
        }

        function generatePrompt() {
            // Track prompt generation in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'generate_ai_prompt', {
                    'include_calendar': includeCalendar.checked,
                    'include_relevant_plants_only': includeRelevantPlantsOnly.checked
                });
            }
            
            // Get current location info
            let locationInfo = '';
            const weatherLocationInfo = document.querySelector('.weather-location-info');
            if (weatherLocationInfo) {
                locationInfo = weatherLocationInfo.textContent.trim();
            }

            // Get climate zone
            let climateZone = '';
            const climateZoneCode = document.getElementById('climateZoneCode');
            if (climateZoneCode) {
                climateZone = climateZoneCode.textContent.trim();
            }

            // Get current weather
            let currentWeather = '';
            const weatherCurrent = document.querySelector('.weather-current');
            if (weatherCurrent) {
                currentWeather = weatherCurrent.textContent.trim();
            }

            // Get forecast summary (next 7 days)
            let forecastSummary = '';
            const forecastTable = document.querySelector('.weather-forecast-table tbody');
            if (forecastTable) {
                const next7Days = Array.from(forecastTable.querySelectorAll('tr')).slice(0, 7);
                forecastSummary = next7Days.map(row => {
                    const cells = row.querySelectorAll('td');
                    return `- ${cells[0].textContent}:\n  ${cells[6].textContent.split('\n')[1]}\n  Max: ${cells[4].textContent}, Precipitation: ${cells[5].textContent}`;
                }).join('\n\n');
            }

            // Get current month's planting calendar with only selected items
            let plantingCalendar = '';
            if (includeCalendar.checked) {
                const selections = getSelectedItems();
                const currentSelections = selections[activeMonth];
                
                if (currentSelections && Object.keys(currentSelections).length > 0) {
                    const plantItems = [];
                    Object.entries(currentSelections).forEach(([category, items]) => {
                        if (items.length > 0) {
                            const filteredItems = items.filter(item => {
                                if (!includeRelevantPlantsOnly.checked || !lastWeatherData) return true;
                                return isPlantSuitableForWeather(item, lastWeatherData);
                            });
                            if (filteredItems.length > 0) {
                                plantItems.push(`${categoryNames[category] || category}:\n${filteredItems.join('\n')}`);
                            }
                        }
                    });
                    if (plantItems.length > 0) {
                        plantingCalendar = 'Selected Plants and Tasks:\n\n' + plantItems.join('\n\n');
                    }
                }

                // If no selections, add a note
                if (!plantingCalendar) {
                    plantingCalendar = 'No plants or tasks selected yet. Please check items in the calendar that interest you.\n';
                }
            }

            // Get user's custom notes
            const notes = customNotes.value.trim();

            // Construct the prompt
            const prompt = `I need advice for my garden based on the following information:

Location and Climate:
${locationInfo.replace(/Location:/g, "Location:").replace(/Latitude:/g, "\nLatitude:")}

K√∂ppen Climate Zone: ${climateZone}
${includeRelevantPlantsOnly.checked ? '(Recommendations filtered for current weather conditions)' : ''}

Current Weather and Forecast:
${currentWeather}

7-Day Forecast:
${forecastSummary}

${plantingCalendar}

${notes ? `Additional Notes:\n${notes}\n\n` : ''}Based on this information, please provide:
1. Immediate tasks I should focus on this week
2. What I should plant now or prepare for planting
3. Potential weather-related precautions
4. Long-term planning suggestions
5. Any specific care instructions for my selected plants

Please be specific and consider the weather forecast and climate zone in your recommendations.`;

            generatedPrompt.textContent = prompt;
            
            // Show AI assistants section
            document.getElementById('promptDestinationSection').style.display = 'block';
        }

        function copyPrompt() {
            navigator.clipboard.writeText(generatedPrompt.textContent)
                .then(() => {
                    const originalText = copyPromptBtn.textContent;
                    copyPromptBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyPromptBtn.textContent = originalText;
                    }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy text:', err);
                    alert('Failed to copy to clipboard. Please select and copy the text manually.');
                });
        }

        // Send prompt to AI assistant
        function sendToAiAssistant(assistant) {
            // Track which AI assistant was selected in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'send_to_ai_assistant', {
                    'assistant': assistant
                });
            }
            
            const prompt = encodeURIComponent(generatedPrompt.textContent);
            let url = '';
            
            switch(assistant) {
                case 'chatgpt':
                    url = `https://chat.openai.com?prompt=${prompt}`;
                    break;
                case 'claude':
                    url = `https://claude.ai/new?q=${prompt}`;
                    break;
                case 'gemini':
                    url = `https://gemini.google.com/}`;
                    break;
                case 'copilot':
                    url = `https://copilot.microsoft.com/?q=${prompt}`;
                    break;
                case 'mistral':
                    url = `https://chat.mistral.ai/chat`;
                    break;
                case 'deepseek':
                    url = `https://chat.deepseek.com`;
                    break;
                default:
                    alert('Selected AI assistant is not supported.');
                    return;
            }
            
            // Open in a new tab
            window.open(url, '_blank');
        }

        // Set up event listeners
        generatePromptBtn.addEventListener('click', generatePrompt);
        copyPromptBtn.addEventListener('click', copyPrompt);
        
        // AI assistant buttons
        document.querySelector('.ai-assistants-grid').addEventListener('click', (e) => {
            const btn = e.target.closest('.ai-assistant-btn');
            if (btn) {
                const assistant = btn.dataset.assistant;
                sendToAiAssistant(assistant);
            }
        });

        // Don't automatically generate on weather update anymore since it's in a modal
        const originalRenderWeatherData = renderWeatherData;
        renderWeatherData = function(data) {
            originalRenderWeatherData.call(this, data);
        };

        // Selection storage functionality
        function getSelectedItems() {
            const stored = localStorage.getItem('gardening_selected_items');
            return stored ? JSON.parse(stored) : {};
        }

        function isItemSelected(month, category, item) {
            const selections = getSelectedItems();
            return selections[month]?.[category]?.includes(item) || false;
        }

        function toggleItemSelection(month, category, item, selected) {
            const selections = getSelectedItems();
            
            // Initialize nested structure if needed
            if (!selections[month]) selections[month] = {};
            if (!selections[month][category]) selections[month][category] = [];
            
            const items = selections[month][category];
            const index = items.indexOf(item);
            
            if (selected && index === -1) {
                items.push(item);
            } else if (!selected && index !== -1) {
                items.splice(index, 1);
            }
            
            // Clean up empty arrays and objects
            if (items.length === 0) delete selections[month][category];
            if (Object.keys(selections[month]).length === 0) delete selections[month];
            
            localStorage.setItem('gardening_selected_items', JSON.stringify(selections));
        }

        // Add scroll-related event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTop = document.getElementById('scrollToTop');
            const calendarContent = document.getElementById('calendarContent');
            const quickJumpMenu = document.getElementById('quickJumpMenu');
            const header = document.querySelector('header');

            // Handle header scroll state
            function updateHeaderState() {
                if (window.pageYOffset > 50) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }
            }

            // Throttle scroll event handling
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                if (!scrollTimeout) {
                    scrollTimeout = setTimeout(() => {
                        updateHeaderState();
                        scrollTimeout = null;
                    }, 10);
                }
            });

            // Initial header state
            updateHeaderState();

            // Quick jump functionality
            quickJumpMenu.addEventListener('click', (e) => {
                const btn = e.target.closest('.quick-jump-btn');
                if (!btn) return;
                
                // Remove active class from all buttons
                quickJumpMenu.querySelectorAll('.quick-jump-btn').forEach(b => b.classList.remove('active'));
                
                const sectionId = btn.dataset.section;
                const section = document.getElementById(sectionId);
                
                if (section) {
                    // Add active class to clicked button
                    btn.classList.add('active');
                    
                    // Scroll to section with offset for header
                    const headerHeight = document.querySelector('header').offsetHeight;
                    const sectionTop = section.getBoundingClientRect().top + window.pageYOffset;
                    window.scrollTo({
                        top: sectionTop - headerHeight - 20,
                        behavior: 'smooth'
                    });
                }
            });

            // Track scroll position to highlight current section
            let ticking = false;
            window.addEventListener('scroll', () => {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        const headerHeight = document.querySelector('header').offsetHeight;
                        const sections = [
                            'location-setup',
                            'weather-info',
                            'search-section',
                            'monthly-calendar'
                        ].map(id => document.getElementById(id));
                        
                        // Find the current section in view
                        const currentSection = sections.find(section => {
                            if (!section) return false;
                            const rect = section.getBoundingClientRect();
                            return rect.top <= headerHeight + 50 && rect.bottom > headerHeight;
                        });
                        
                        // Update active button
                        const buttons = quickJumpMenu.querySelectorAll('.quick-jump-btn');
                        buttons.forEach(btn => {
                            const sectionId = btn.dataset.section;
                            if (currentSection && currentSection.id === sectionId) {
                                btn.classList.add('active');
                            } else {
                                btn.classList.remove('active');
                            }
                        });
                        
                        ticking = false;
                    });
                    ticking = true;
                }
            });

            // Show/hide scroll to top button
            window.addEventListener('scroll', () => {
                if (window.pageYOffset > 300) {
                    scrollToTop.style.display = 'flex';
                    setTimeout(() => scrollToTop.classList.add('visible'), 10);
                } else {
                    scrollToTop.classList.remove('visible');
                    setTimeout(() => {
                        if (!scrollToTop.classList.contains('visible')) {
                            scrollToTop.style.display = 'none';
                        }
                    }, 300);
                }
            });

            // Smooth scroll to top
            scrollToTop.addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });
    </script>
</body>
</html> 