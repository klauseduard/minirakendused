<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Gardening and Planting Calendar</title>
    <style>
        :root {
            --primary-color: #4a8e3a;
            --secondary-color: #8bc34a;
            --accent-color: #3e7d32;
            --light-bg: #f1f8e9;
            --dark-bg: #e8f5e9;
            --white: #ffffff;
            --black: #212121;
            --shadow: rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--light-bg);
            color: var(--black);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 12px 10px 10px 10px;
            background-color: var(--primary-color);
            color: var(--white);
            border-radius: 10px;
            box-shadow: 0 4px 6px var(--shadow);
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 6px;
        }
        
        .description {
            font-size: 1rem;
            font-weight: 400;
            color: #224c2a;
            margin: 0 auto;
            max-width: 700px;
        }
        
        .main-layout {
            max-width: 1200px;
            margin: 0 auto;
        }

        .top-controls {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .location-row {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 15px;
            margin-bottom: 20px;
            align-items: start;
        }

        .units-row {
            display: flex;
            gap: 25px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .unit-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .weather-display {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .search-bar {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .search-section-title {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 500;
        }

        .search-container {
            width: 100%;
        }

        .search-box {
            width: 100%;
            padding: 12px 20px;
            font-size: 1rem;
            border: 2px solid var(--secondary-color);
            border-radius: 30px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .search-box:focus {
            border-color: var(--primary-color);
        }

        .month-navigation {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .month-nav-title {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 500;
        }

        .calendar-nav {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .month-btn {
            padding: 12px 25px;
            background-color: var(--secondary-color);
            color: var(--white);
            border: none;
            border-radius: 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px var(--shadow);
            min-width: 120px;
            text-align: center;
        }

        .month-btn:hover {
            background-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .month-btn.active {
            background-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow);
        }

        @media (max-width: 768px) {
            .calendar-nav {
                justify-content: center;
            }

            .month-btn {
                min-width: 140px;
            }
        }

        .calendar-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .category-card {
            background-color: var(--white);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px var(--shadow);
            transition: transform 0.3s ease;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .category-card:last-child {
            grid-column: 1 / -1;
        }

        .garden-tasks-card {
            grid-column: 1 / -1;
        }
        
        .category-card .plant-list {
            flex-grow: 1;
        }
        
        .category-card:hover {
            transform: translateY(-5px);
        }
        
        .category-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .category-icon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
            background-color: var(--secondary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-size: 1.2rem;
        }
        
        .category-title {
            font-size: 1.3rem;
            color: var(--primary-color);
        }
        
        .plant-list {
            list-style-type: none;
        }
        
        .plant-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
        }
        
        .plant-item:last-child {
            border-bottom: none;
        }
        
        .plant-item::before {
            content: "🌱";
            margin-right: 10px;
        }
        
        .task-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
        }
        
        .task-item:last-child {
            border-bottom: none;
        }
        
        .task-item::before {
            content: "✓";
            margin-right: 10px;
        }
        
        .item-label {
            width: 100%;
            padding: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .item-label:hover {
            background: var(--light-bg);
        }

        .item-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary-color);
            margin: 0;
        }

        .item-text {
            flex: 1;
            padding: 2px 0;
        }
        
        .highlight {
            background-color: #ffe066;
            padding: 2px;
            border-radius: 3px;
        }
        
        .no-results {
            text-align: center;
            padding: 20px;
            font-size: 1.2rem;
            color: #757575;
            grid-column: 1 / -1;
        }
        
        .mobile-warning {
            display: none;
            text-align: center;
            padding: 10px;
            background-color: #fff3e0;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        
        @media (max-width: 768px) {
            .location-row {
                grid-template-columns: 1fr;
            }
            
            .search-bar {
                flex-direction: column;
            }
            
            .search-container {
                width: 100%;
            }
            
            .ai-advice-btn {
                width: 100%;
            }
            
            .mobile-warning {
                display: block;
            }
        }

        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: static;
            }

            .action-bar {
                flex-direction: column;
            }

            .search-container {
                width: 100%;
            }

            .ai-advice-btn {
                width: 100%;
                justify-content: center;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease forwards;
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #757575;
            font-size: 0.9rem;
        }
        
        .weather-section {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 15px;
        }
        
        .weather-location-row {
            margin-bottom: 10px;
        }
        
        .weather-location-info {
            margin-bottom: 18px;
            font-size: 1.08em;
        }
        
        .weather-forecast-table {
            width: 100%;
            font-size: 0.97em;
            margin-top: 10px;
            border-collapse: separate;
            border-spacing: 0 6px;
            background: #f8faf5;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 4px rgba(74,142,58,0.07);
        }
        
        .weather-forecast-table th, .weather-forecast-table td {
            padding: 7px 14px;
            text-align: center;
        }
        
        .weather-forecast-table th {
            background: #e8f5e9;
            color: #3e7d32;
            font-weight: 600;
            border-bottom: 2px solid #c8e6c9;
        }
        
        .weather-forecast-table td {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .weather-forecast-table tr:last-child td {
            border-bottom: none;
        }
        
        .weather-forecast-table td svg {
            display: block;
            margin: 0 auto;
            cursor: pointer;
        }
        
        .weather-current {
            margin-bottom: 10px;
            font-size: 1.08em;
        }
        
        .location-input {
            padding: 10px 16px;
            border: 2px solid var(--secondary-color);
            border-radius: 30px;
            font-size: 1rem;
            outline: none;
            min-width: 520px;
        }
        
        .location-btn {
            padding: 10px 18px;
            background-color: var(--secondary-color);
            color: var(--white);
            border: none;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .location-btn:hover {
            background-color: var(--accent-color);
        }
        
        .weather-placeholder {
            color: #333;
            font-size: 1.1rem;
        }
        
        /* Modal for detailed weather */
        .weather-modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.25);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .weather-modal {
            background: var(--light-bg);
            border-radius: 14px;
            box-shadow: 0 4px 24px var(--shadow);
            padding: 28px 32px 24px 32px;
            min-width: 340px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .weather-modal-close {
            position: absolute;
            top: 10px;
            right: 16px;
            font-size: 1.4em;
            color: #7cb342;
            background: none;
            border: none;
            cursor: pointer;
            transition: color 0.2s;
        }
        .weather-modal-close:hover {
            color: #388e3c;
        }
        .weather-modal-title {
            font-size: 1.18em;
            margin-bottom: 18px;
            color: var(--primary-color);
            font-weight: 600;
            letter-spacing: 0.01em;
        }
        .weather-modal-chart {
            margin-bottom: 18px;
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 1px 4px var(--shadow);
            padding: 12px 8px 8px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .weather-modal-hourly-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 4px;
            font-size: 0.98em;
            background: #f8faf5;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 4px rgba(74,142,58,0.07);
            margin-top: 8px;
        }
        .weather-modal-hourly-table th, .weather-modal-hourly-table td {
            padding: 6px 12px;
            text-align: center;
        }
        .weather-modal-hourly-table th {
            background: #e8f5e9;
            color: #3e7d32;
            font-weight: 600;
        }
        .weather-modal-hourly-table td {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
        }
        .weather-modal-hourly-table tr:last-child td {
            border-bottom: none;
        }
        .weather-forecast-table tr:nth-child(even) td,
        .weather-modal-hourly-table tr:nth-child(even) td {
            background: #f1f8e9;
        }
        /* Visually hidden class for accessibility */
        .visually-hidden {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }
        .month-btn:focus, .location-btn:focus, .weather-modal-close:focus {
            outline: 3px solid #1976d2 !important;
            outline-offset: 2px;
        }
        .item-label {
            width: 100%;
            padding: 4px 0;
        }
        .item-label:hover {
            background: var(--light-bg);
        }
        .item-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary-color);
        }
        .item-text {
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Spring Gardening and Planting Calendar</h1>
            <p class="description">Plan your garden tasks and sowing by month—with local weather forecasts.</p>
        </header>

        <main class="main-layout">
            <!-- Location and Units Controls -->
            <section class="top-controls">
                <div class="location-row">
                    <div class="location-input-group">
                        <label for="locationInput" class="visually-hidden">Location</label>
                        <input type="text" class="location-input" id="locationInput" 
                            placeholder="Enter place name, village, postal code, or coordinates..." 
                            aria-label="Location">
                    </div>
                    <button class="location-btn" id="useMyLocationBtn">Use my location</button>
                </div>
                <div class="units-row">
                    <div class="unit-group">
                        <label for="tempUnitSelect">Temperature:</label>
                        <select id="tempUnitSelect" aria-label="Temperature unit">
                            <option value="C">Celsius (°C)</option>
                            <option value="F">Fahrenheit (°F)</option>
                        </select>
                    </div>
                    <div class="unit-group">
                        <label for="precipUnitSelect">Precipitation:</label>
                        <select id="precipUnitSelect" aria-label="Precipitation unit">
                            <option value="mm">Millimeters (mm)</option>
                            <option value="in">Inches (in)</option>
                        </select>
                    </div>
                </div>
                <div id="climateZoneInfo"></div>
            </section>

            <!-- Weather Display -->
            <section class="weather-display">
                <div class="weather-placeholder" id="weatherPlaceholder">
                    Weather information for your location will appear here.
                </div>
            </section>

            <!-- Search Bar -->
            <section class="search-bar">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 class="search-section-title">Find Plants and Tasks</h2>
                    <button id="aiAdviceBtn" class="ai-advice-btn" style="padding: 8px 16px; background: var(--secondary-color); color: white; border: none; border-radius: 20px; display: flex; align-items: center; gap: 8px; font-weight: 500; cursor: pointer; transition: background-color 0.3s;">
                        <span style="font-size: 1.2em;">🤖</span>
                        <span>Generate AI gardening advice prompt</span>
                    </button>
                </div>
                <div class="search-container">
                    <label for="searchBox" class="visually-hidden">Search for plants or tasks</label>
                    <input type="text" class="search-box" id="searchBox" 
                        placeholder="Type to search for specific plants or garden tasks..." 
                        aria-label="Search for plants or tasks">
                </div>
            </section>

            <!-- Month Navigation -->
            <section class="month-navigation">
                <h2 class="month-nav-title">Select Growing Period</h2>
                <div class="calendar-nav">
                    <button class="month-btn active" data-month="april">April</button>
                    <button class="month-btn" data-month="may">May</button>
                    <button class="month-btn" data-month="early_june">Early June</button>
                </div>
            </section>

            <!-- Calendar Content -->
            <section class="calendar-content" id="calendarContent">
                <!-- Content will be added by JavaScript -->
            </section>
        </main>

        <!-- Prompt Generator Modal -->
        <div id="promptGeneratorModal" class="weather-modal-overlay" style="display: none;">
            <div class="weather-modal" style="width: 90%; max-width: 800px;">
                <button class="weather-modal-close" id="closePromptGeneratorBtn" aria-label="Close prompt generator">&times;</button>
                <div class="weather-modal-title">AI Gardening Assistant</div>
                <div style="margin: 20px 0;">
                    <p style="margin-bottom: 15px; color: #666;">
                        This tool will generate a comprehensive prompt based on your location, weather, and garden information. 
                        You can use this prompt with any AI assistant to get personalized gardening advice.
                    </p>
                    <div style="margin-bottom: 15px;">
                        <label for="customNotes" style="display: block; margin-bottom: 8px; font-weight: 500;">Your notes about your garden:</label>
                        <textarea id="customNotes" rows="4" style="width: 100%; padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; margin-bottom: 10px;" placeholder="Describe your garden's current state, what you've already done, or ask specific questions..."></textarea>
                    </div>
                    <div style="margin-bottom: 15px; padding: 12px; background: #fff3e0; border-radius: 8px;">
                        <h3 style="margin-bottom: 10px; color: #e65100; font-size: 1rem;">Include in Prompt:</h3>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="display: block;">
                                <input type="checkbox" id="includeCalendar" checked>
                                Selected plants and tasks
                                <span style="margin-left: 5px; color: #666; font-size: 0.9em;">
                                    (Your checked items from the planting calendar)
                                </span>
                            </label>
                            <label style="display: block;">
                                <input type="checkbox" id="includeRelevantPlantsOnly" checked>
                                Filter for weather conditions
                                <span style="margin-left: 5px; color: #666; font-size: 0.9em;">
                                    (Only include plants suitable for current forecast)
                                </span>
                            </label>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button id="generatePromptBtn" class="location-btn">Generate Prompt</button>
                        <button id="copyPromptBtn" class="location-btn" style="background: var(--accent-color);">Copy to Clipboard</button>
                    </div>
                    <div id="generatedPrompt" style="background: #f8faf5; border-radius: 8px; padding: 15px; white-space: pre-wrap; font-family: monospace; max-height: 400px; overflow-y: auto;">
                        Click "Generate Prompt" to create a customized gardening prompt based on your location, weather, and calendar data.
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Spring Gardening and Planting Calendar © 2025</p>
        </footer>
    </div>

    <script>
        // Data in JSON format
        const calendarData = {
            "april": {
                "direct_sowing": [
                    "carrot",
                    "parsnip",
                    "radish",
                    "turnip",
                    "peas",
                    "spinach",
                    "arugula",
                    "lettuce",
                    "dill",
                    "parsley"
                ],
                "seedling_start": [
                    "cabbage",
                    "cauliflower",
                    "broccoli",
                    "kale",
                    "tomato",
                    "pepper",
                    "eggplant",
                    "pumpkin",
                    "zucchini",
                    "melon",
                    "basil",
                    "thyme",
                    "sage"
                ],
                "greenhouse": [
                    "radish",
                    "spinach",
                    "lettuce",
                    "dill"
                ],
                "garden_tasks": [
                    "Pruning fruit trees and berry bushes (before bud break)",
                    "Cleaning strawberry beds",
                    "Turning compost",
                    "Cleaning and preparing greenhouse",
                    "Loosening and fertilizing beds"
                ]
            },
            "may": {
                "direct_sowing": [
                    "carrot",
                    "beetroot",
                    "radish",
                    "turnip",
                    "parsnip",
                    "dill",
                    "parsley",
                    "lettuce",
                    "arugula",
                    "spinach (new sowing)",
                    "chard",
                    "peas",
                    "beans",
                    "potato",
                    "onion (sets or seeds)"
                ],
                "transplanting": [
                    "cabbage",
                    "cauliflower",
                    "broccoli",
                    "kale",
                    "tomato (in greenhouse)",
                    "pepper (in greenhouse)",
                    "eggplant (in greenhouse)",
                    "zucchini (late May)",
                    "pumpkin (late May)"
                ],
                "greenhouse": [
                    "tomato",
                    "cucumber",
                    "pepper",
                    "eggplant",
                    "zucchini",
                    "basil"
                ],
                "garden_tasks": [
                    "Checking fruit tree flower buds (thinning if needed)",
                    "Planting containers and balcony plants",
                    "Adding mulch to beds",
                    "Weed control",
                    "Adding green matter to compost"
                ]
            },
            "early_june": {
                "direct_sowing": [
                    "beans (late varieties)",
                    "zucchini (direct sowing)",
                    "cucumber (direct sowing)"
                ],
                "transplanting": [
                    "zucchini",
                    "pumpkin",
                    "cucumber (if soil is warm)"
                ],
                "greenhouse": [
                    "Tomato maintenance and staking",
                    "Fertilizing",
                    "Ventilation",
                    "Removing side shoots",
                    "Succession planting (lettuce, radish, herbs)",
                    "Cucumber staking"
                ],
                "garden_tasks": [
                    "Removing row covers",
                    "Monitoring watering schedule",
                    "Weed control",
                    "Covering strawberries with bird netting"
                ]
            }
        };

        // Category icons
        const categoryIcons = {
            "direct_sowing": "🌱",
            "seedling_start": "🌿",
            "transplanting": "🌿",
            "greenhouse": "🏡",
            "garden_tasks": "🧰"
        };

        // Category names
        const categoryNames = {
            "direct_sowing": "Direct Sowing",
            "seedling_start": "Starting Seedlings",
            "transplanting": "Transplanting",
            "greenhouse": "Greenhouse",
            "garden_tasks": "Garden Tasks"
        };

        // DOM elements
        const calendarContent = document.getElementById('calendarContent');
        const monthButtons = document.querySelectorAll('.month-btn');
        const searchBox = document.getElementById('searchBox');

        // Active month (default April)
        let activeMonth = 'april';

        // Track last actions for retry
        let lastGeocodeQuery = null;
        let lastWeatherCoords = null;
        let lastWeatherAction = null; // 'geocode' or 'weather'

        // Store last fetched weather data for re-rendering
        let lastWeatherData = null;
        let lastWeatherLat = null;
        let lastWeatherLon = null;

        // --- Köppen climate zone logic ---
        let koppenGrid = null;
        let userClimateZone = null;
        let userClimateZoneOverride = null;
        const climateZoneInfo = document.getElementById('climateZoneInfo');

        // Load the grid JSON
        fetch('gardening_calendar/data/koppen_grid_0.5deg.json')
            .then(r => r.json())
            .then(data => {
                koppenGrid = data;
                // If we already have a location, try to show zone
                const cached = localStorage.getItem('gardening_last_location');
                if (cached) {
                    try {
                        const loc = JSON.parse(cached);
                        if (loc.type === 'coords' && loc.lat && loc.lon) {
                            showClimateZone(loc.lat, loc.lon);
                        }
                    } catch (e) {}
                }
            });

        // Helper: round to nearest 0.25
        function round025(x) {
            // Ensure x is a number and round to either .25 or .75
            const num = typeof x === 'string' ? parseFloat(x) : x;
            const decimal = num % 1;
            const whole = Math.floor(num);
            let rounded;
            if (decimal < 0.375) {
                rounded = 0.25;
            } else if (decimal < 0.875) {
                rounded = 0.75;
            } else {
                rounded = 0.25;
                return (whole + 1 + rounded).toFixed(2);
            }
            return (whole + rounded).toFixed(2);
        }

        // Show climate zone info
        function showClimateZone(lat, lon) {
            if (!koppenGrid) {
                climateZoneInfo.innerHTML = '';
                return;
            }
            // Check for override
            const override = localStorage.getItem('gardening_climate_zone_override');
            let lookupKey = '';
            let foundZone = '';
            if (override) {
                userClimateZoneOverride = override;
                userClimateZone = override;
                lookupKey = '(override)';
                foundZone = override;
            } else {
                const latNum = typeof lat === 'string' ? parseFloat(lat) : lat;
                const lonNum = typeof lon === 'string' ? parseFloat(lon) : lon;
                const key = `${round025(latNum)} ${round025(lonNum)}`;
                // Try exact match first
                if (koppenGrid[key]) {
                    userClimateZone = koppenGrid[key];
                    lookupKey = key;
                    foundZone = userClimateZone;
                } else {
                    // Find nearest neighbor
                    const roundedLat = round025(latNum);
                    const roundedLon = round025(lonNum);
                    let minDistance = Infinity;
                    let nearestZone = null;
                    let nearestKey = null;
                    
                    // Search in nearby coordinates (±1 degree should be enough)
                    for (const gridKey in koppenGrid) {
                        const [gridLat, gridLon] = gridKey.split(' ').map(Number);
                        if (Math.abs(gridLat - roundedLat) <= 1 && Math.abs(gridLon - roundedLon) <= 1) {
                            const distance = Math.sqrt(
                                Math.pow(gridLat - roundedLat, 2) + 
                                Math.pow(gridLon - roundedLon, 2)
                            );
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestZone = koppenGrid[gridKey];
                                nearestKey = gridKey;
                            }
                        }
                    }
                    
                    if (nearestZone) {
                        userClimateZone = nearestZone;
                        lookupKey = `${key} (nearest: ${nearestKey}, dist: ${minDistance.toFixed(2)}°)`;
                        foundZone = nearestZone;
                    } else {
                        userClimateZone = 'Unknown';
                        lookupKey = key;
                        foundZone = 'Unknown';
                    }
                }
            }
            renderClimateZoneUI(lookupKey, foundZone);
        }

        // Render the climate zone UI (with debug info)
        function renderClimateZoneUI(lookupKey = '', foundZone = '') {
            let html = '';
            if (userClimateZone) {
                html += `<div style="margin-top: 15px; padding: 10px 15px; background: var(--white); border-radius: 8px; box-shadow: 0 1px 3px var(--shadow);">`;
                html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">`;
                html += `<strong>Climate zone:</strong> <span id="climateZoneCode" style="background: var(--light-bg); padding: 2px 8px; border-radius: 4px; font-family: monospace;">${userClimateZone}</span>`;
                html += `<a href="https://en.wikipedia.org/wiki/K%C3%B6ppen_climate_classification" target="_blank" style="color: var(--primary-color); text-decoration: none; font-size: 0.95em;">(What is this?)</a>`;
                html += `</div>`;
                html += `<div style="display: flex; align-items: center; gap: 10px;">`;
                html += `<label for="climateZoneOverride" style="font-size: 0.95em;">Override zone:</label>`;
                html += `<input id="climateZoneOverride" type="text" style="padding: 4px 8px; border: 1px solid var(--secondary-color); border-radius: 4px; width: 60px;" value="${userClimateZoneOverride || ''}" placeholder="e.g. Dfb">`;
                html += `<button id="setClimateZoneOverrideBtn" style="padding: 4px 10px; background: var(--secondary-color); color: white; border: none; border-radius: 4px; font-size: 0.95em; cursor: pointer;">Set</button>`;
                html += `<button id="clearClimateZoneOverrideBtn" style="padding: 4px 10px; background: var(--accent-color); color: white; border: none; border-radius: 4px; font-size: 0.95em; cursor: pointer;">Clear</button>`;
                html += `</div></div>`;
            }
            climateZoneInfo.innerHTML = html;

            // Add listeners
            const setBtn = document.getElementById('setClimateZoneOverrideBtn');
            const clearBtn = document.getElementById('clearClimateZoneOverrideBtn');
            if (setBtn) {
                setBtn.addEventListener('click', function() {
                    const val = document.getElementById('climateZoneOverride').value.trim();
                    if (val) {
                        localStorage.setItem('gardening_climate_zone_override', val);
                        userClimateZoneOverride = val;
                        userClimateZone = val;
                        renderClimateZoneUI();
                    }
                });
            }
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    localStorage.removeItem('gardening_climate_zone_override');
                    userClimateZoneOverride = null;
                    // Recompute from location
                    const cached = localStorage.getItem('gardening_last_location');
                    if (cached) {
                        try {
                            const loc = JSON.parse(cached);
                            if (loc.type === 'coords' && loc.lat && loc.lon) {
                                const latNum = typeof loc.lat === 'string' ? parseFloat(loc.lat) : loc.lat;
                                const lonNum = typeof loc.lon === 'string' ? parseFloat(loc.lon) : loc.lon;
                                showClimateZone(latNum, lonNum);
                                return;
                            }
                        } catch (e) {}
                    }
                    renderClimateZoneUI();
                });
            }
        }

        // Helper: Convert temperature and precipitation
        function convertTemp(val, unit) {
            if (unit === 'F') return Math.round(val * 9/5 + 32);
            return Math.round(val);
        }
        function convertPrecip(val, unit) {
            if (unit === 'in') return (val / 25.4).toFixed(2);
            return val;
        }
        function getTempUnitSymbol() {
            return tempUnitSelect.value === 'F' ? '°F' : '°C';
        }
        function getPrecipUnitSymbol() {
            return precipUnitSelect.value === 'in' ? 'in' : 'mm';
        }

        // Function to render calendar content
        function renderCalendar(month, searchTerm = '') {
            // Clear content
            calendarContent.innerHTML = '';
            
            // Check if month has data
            if (!calendarData[month]) {
                calendarContent.innerHTML = '<div class="no-results">No data available for selected month.</div>';
                return;
            }
            
            // Show categories
            const categories = Object.keys(calendarData[month]);
            
            // Filter for search
            let hasResults = false;
            let delay = 0;
            
            categories.forEach(category => {
                const items = calendarData[month][category];
                let filteredItems = items;
                
                // Apply filter if search term exists
                if (searchTerm) {
                    filteredItems = items.filter(item => 
                        item.toLowerCase().includes(searchTerm.toLowerCase())
                    );
                }
                
                // Don't show category if no results after filtering
                if (filteredItems.length === 0 && searchTerm) {
                    return;
                }
                
                hasResults = true;
                
                // Create category card
                const categoryCard = document.createElement('div');
                const categoryClass = category === 'garden_tasks' ? 'category-card garden-tasks-card' : 'category-card';
                categoryCard.className = `${categoryClass} fade-in`;
                categoryCard.style.animationDelay = `${delay}ms`;
                delay += 100;
                
                // Icon and title
                const isTaskCategory = category === 'garden_tasks';
                
                categoryCard.innerHTML = `
                    <div class="category-header">
                        <div class="category-icon">${categoryIcons[category] || '🌿'}</div>
                        <h2 class="category-title">${categoryNames[category] || category}</h2>
                    </div>
                    <ul class="plant-list">
                        ${filteredItems.map(item => `
                            <li class="${isTaskCategory ? 'task-item' : 'plant-item'}" data-item-id="${encodeURIComponent(item)}">
                                <label class="item-label">
                                    <input type="checkbox" class="item-checkbox" 
                                        ${isItemSelected(month, category, item) ? 'checked' : ''}>
                                    <span class="item-text">${searchTerm ? highlightText(item, searchTerm) : item}</span>
                                </label>
                            </li>
                        `).join('')}
                    </ul>
                `;

                // Add event listeners for checkboxes
                categoryCard.querySelectorAll('.item-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const item = decodeURIComponent(e.target.closest('li').dataset.itemId);
                        toggleItemSelection(month, category, item, e.target.checked);
                    });
                });
                
                calendarContent.appendChild(categoryCard);
            });
            
            // If no results found
            if (!hasResults) {
                calendarContent.innerHTML = '<div class="no-results">No results found for your search.</div>';
            }
        }

        // Search function
        function searchCalendar() {
            const searchTerm = searchBox.value.trim();
            renderCalendar(activeMonth, searchTerm);
        }

        // Text highlighting function
        function highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            
            const regex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        // Escape special characters in regular expression
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Listen for month button clicks
        monthButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons
                monthButtons.forEach(btn => btn.classList.remove('active'));
                
                // Add active class to clicked button
                button.classList.add('active');
                
                // Update active month
                activeMonth = button.dataset.month;
                
                // Show calendar
                searchBox.value = ''; // Reset search
                renderCalendar(activeMonth);
            });
        });

        // Listen for search input
        searchBox.addEventListener('input', searchCalendar);

        // Initial calendar display
        renderCalendar(activeMonth);

        // Weather/location handling
        const locationInput = document.getElementById('locationInput');
        const useMyLocationBtn = document.getElementById('useMyLocationBtn');
        const weatherPlaceholder = document.getElementById('weatherPlaceholder');

        // Helper: Display error with optional retry
        function displayLocationError(msg, retryType = null) {
            let retryBtn = '';
            if (retryType === 'geocode') {
                retryBtn = '<button id="retryGeocodeBtn" style="margin-left:12px;">Retry</button>';
            } else if (retryType === 'weather') {
                retryBtn = '<button id="retryWeatherBtn" style="margin-left:12px;">Retry</button>';
            }
            weatherPlaceholder.innerHTML = `<div role="alert" style="color: #b71c1c;">${msg}${retryBtn}</div>`;
            if (retryType === 'geocode') {
                const btn = document.getElementById('retryGeocodeBtn');
                if (btn) btn.onclick = () => {
                    if (lastGeocodeQuery) geocodeLocation(lastGeocodeQuery, true);
                };
            } else if (retryType === 'weather') {
                const btn = document.getElementById('retryWeatherBtn');
                if (btn) btn.onclick = () => {
                    if (lastWeatherCoords) fetchWeatherData(lastWeatherCoords.lat, lastWeatherCoords.lon, true);
                };
            }
        }

        // Helper: Display location and coordinates, then fetch and display weather
        function displayLocationInfo(name, lat, lon, admin1, admin2, country) {
            let locationParts = [];
            if (name) locationParts.push(name);
            if (admin2) locationParts.push(admin2);
            if (admin1) locationParts.push(admin1);
            if (country) locationParts.push(country);
            const locationString = locationParts.join(', ');
            weatherPlaceholder.innerHTML =
                `<div class="weather-location-info"><strong>Location:</strong> ${locationString}<br>` +
                `<span style="font-size:0.97em;color:#666;">Latitude: ${lat}, Longitude: ${lon}</span></div>` +
                `<div id="weatherDataSection">Loading weather data...</div>`;
            lastWeatherCoords = { lat, lon };
            lastWeatherAction = 'weather';
            fetchWeatherData(lat, lon);
            showClimateZone(lat, lon);
        }

        // Weather code to icon, text, and color (Open-Meteo codes)
        function weatherCodeToIconTextColor(code) {
            // Weather type to color mapping
            const typeColors = {
                sun:   { bg: '#fffde7', color: '#fbc02d' },
                cloud: { bg: '#eceff1', color: '#607d8b' },
                rain:  { bg: '#e3f2fd', color: '#1976d2' },
                snow:  { bg: '#f3e5f5', color: '#7e57c2' },
                storm: { bg: '#ffe0b2', color: '#e65100' },
                fog:   { bg: '#f5f5f5', color: '#757575' },
                unknown: { bg: '#eeeeee', color: '#888' }
            };
            // Map weather code to icon, text, and type
            const map = {
                0:  {icon: '☀️', text: 'Clear sky', type: 'sun'},
                1:  {icon: '🌤️', text: 'Mainly clear', type: 'sun'},
                2:  {icon: '⛅', text: 'Partly cloudy', type: 'cloud'},
                3:  {icon: '☁️', text: 'Overcast', type: 'cloud'},
                45: {icon: '🌫️', text: 'Fog', type: 'fog'},
                48: {icon: '🌫️', text: 'Rime fog', type: 'fog'},
                51: {icon: '🌦️', text: 'Light drizzle', type: 'rain'},
                53: {icon: '🌦️', text: 'Drizzle', type: 'rain'},
                55: {icon: '🌦️', text: 'Dense drizzle', type: 'rain'},
                56: {icon: '🌧️', text: 'Freezing light drizzle', type: 'rain'},
                57: {icon: '🌧️', text: 'Freezing drizzle', type: 'rain'},
                61: {icon: '🌦️', text: 'Slight rain', type: 'rain'},
                63: {icon: '🌧️', text: 'Rain', type: 'rain'},
                65: {icon: '🌧️', text: 'Heavy rain', type: 'rain'},
                66: {icon: '🌧️', text: 'Freezing light rain', type: 'rain'},
                67: {icon: '🌧️', text: 'Freezing rain', type: 'rain'},
                71: {icon: '🌨️', text: 'Slight snow fall', type: 'snow'},
                73: {icon: '🌨️', text: 'Snow fall', type: 'snow'},
                75: {icon: '❄️', text: 'Heavy snow fall', type: 'snow'},
                77: {icon: '❄️', text: 'Snow grains', type: 'snow'},
                80: {icon: '🌦️', text: 'Slight rain showers', type: 'rain'},
                81: {icon: '🌧️', text: 'Rain showers', type: 'rain'},
                82: {icon: '🌧️', text: 'Violent rain showers', type: 'rain'},
                85: {icon: '🌨️', text: 'Slight snow showers', type: 'snow'},
                86: {icon: '🌨️', text: 'Snow showers', type: 'snow'},
                95: {icon: '⛈️', text: 'Thunderstorm', type: 'storm'},
                96: {icon: '⛈️', text: 'Thunderstorm w/ hail', type: 'storm'},
                99: {icon: '⛈️', text: 'Thunderstorm w/ heavy hail', type: 'storm'}
            };
            const entry = map[code] || {icon: '❓', text: 'Unknown', type: 'unknown'};
            const color = typeColors[entry.type] || typeColors.unknown;
            return { ...entry, ...color };
        }

        // Fetch weather data from Open-Meteo
        async function fetchWeatherData(lat, lon, isRetry = false) {
            lastWeatherCoords = { lat, lon };
            lastWeatherAction = 'weather';
            lastWeatherLat = lat;
            lastWeatherLon = lon;
            const weatherSection = document.getElementById('weatherDataSection');
            if (!weatherSection) return;
            weatherSection.textContent = 'Loading weather data...';
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weathercode&hourly=temperature_2m,precipitation,windspeed_10m&forecast_days=16&timezone=auto`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Weather service error');
                const data = await response.json();
                lastWeatherData = data;
                if (!data.current_weather || !data.daily || !data.hourly) {
                    weatherSection.innerHTML = '<div role="alert" style="color: #b71c1c;">Weather data not available for this location.</div>';
                    return;
                }
                renderWeatherData(data);
            } catch (e) {
                if (weatherSection) {
                    weatherSection.innerHTML = '<div role="alert" style="color: #b71c1c;">Could not fetch weather data. <button id="retryWeatherBtn" style="margin-left:12px;">Retry</button></div>';
                    const btn = document.getElementById('retryWeatherBtn');
                    if (btn) btn.onclick = () => {
                        if (lastWeatherCoords) fetchWeatherData(lastWeatherCoords.lat, lastWeatherCoords.lon, true);
                    };
                }
            }
        }

        // Render weather data in selected units
        function renderWeatherData(data) {
            const weatherSection = document.getElementById('weatherDataSection');
            if (!weatherSection) return;
            const tempUnit = tempUnitSelect.value;
            const precipUnit = precipUnitSelect.value;
            // Display current weather
            const currentIconTextColor = weatherCodeToIconTextColor(data.current_weather.weathercode);
            let html = `<div class="weather-current"><strong>Current weather:</strong> <span style="display:inline-block;background:${currentIconTextColor.bg};border-radius:50%;padding:6px 10px;font-size:1.4em;color:${currentIconTextColor.color};margin-right:6px;">${currentIconTextColor.icon}</span> ${currentIconTextColor.text}, ${convertTemp(data.current_weather.temperature, tempUnit)}${getTempUnitSymbol()}, Wind: ${data.current_weather.windspeed} km/h</div>`;
            // Prepare hourly data grouped by day
            const hourlyByDay = groupHourlyByDay(data.hourly, data.daily.time);
            const hourlyPrecipByDay = groupHourlyByDay({ time: data.hourly.time, temperature_2m: data.hourly.precipitation }, data.daily.time);
            const hourlyWindByDay = groupHourlyByDay({ time: data.hourly.time, temperature_2m: data.hourly.windspeed_10m }, data.daily.time);
            // Display forecast table
            html += `<div style="margin-top:10px;"><strong>16-day forecast:</strong></div>`;
            html += `<table class="weather-forecast-table"><caption class='visually-hidden'>16-day weather forecast for selected location</caption><thead><tr><th scope='col'>Date</th><th scope='col'>Night Min</th><th scope='col'>Night Max</th><th scope='col'>Day Min</th><th scope='col'>Day Max</th><th scope='col'>Precip.</th><th scope='col'>Weather</th><th scope='col'>Temp Trend</th></tr></thead><tbody>`;
            for (let i = 0; i < data.daily.time.length; i++) {
                const { nightMin, nightMax, dayMin, dayMax } = calcNightDayMinMax(hourlyByDay[i]);
                const weatherIconTextColor = weatherCodeToIconTextColor(data.daily.weathercode[i]);
                html += `<tr><td>${data.daily.time[i]}</td><td>${nightMin !== null ? convertTemp(nightMin, tempUnit) + getTempUnitSymbol() : '-'}</td><td>${nightMax !== null ? convertTemp(nightMax, tempUnit) + getTempUnitSymbol() : '-'}</td><td>${dayMin !== null ? convertTemp(dayMin, tempUnit) + getTempUnitSymbol() : '-'}</td><td>${dayMax !== null ? convertTemp(dayMax, tempUnit) + getTempUnitSymbol() : '-'}</td><td>${convertPrecip(data.daily.precipitation_sum[i], precipUnit)} ${getPrecipUnitSymbol()}</td><td><span style='display:inline-block;background:${weatherIconTextColor.bg};border-radius:50%;padding:7px 12px;font-size:1.5em;color:${weatherIconTextColor.color};margin-bottom:2px;'>${weatherIconTextColor.icon}</span><br><span style='color:${weatherIconTextColor.color};font-size:0.93em;'>${weatherIconTextColor.text}</span></td><td>${renderSparkline(hourlyByDay[i], i, tempUnit)}</td></tr>`;
            }
            html += `</tbody></table>`;
            weatherSection.innerHTML = html;
            // Add event listeners for sparklines
            addSparklineListeners(hourlyByDay, data.daily.time, hourlyPrecipByDay, hourlyWindByDay, tempUnit, precipUnit);
        }

        // Calculate night and day min/max for a day's hourly temps
        function calcNightDayMinMax(temps) {
            if (!temps || temps.length !== 24) return { nightMin: null, nightMax: null, dayMin: null, dayMax: null };
            // Night: 21:00–23:00 (21,22,23) and 00:00–05:00 (0,1,2,3,4,5)
            const nightHours = [21,22,23,0,1,2,3,4,5];
            const dayHours = [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];
            const nightTemps = nightHours.map(h => temps[h]).filter(t => t !== undefined);
            const dayTemps = dayHours.map(h => temps[h]).filter(t => t !== undefined);
            return {
                nightMin: nightTemps.length ? Math.round(Math.min(...nightTemps)) : null,
                nightMax: nightTemps.length ? Math.round(Math.max(...nightTemps)) : null,
                dayMin: dayTemps.length ? Math.round(Math.min(...dayTemps)) : null,
                dayMax: dayTemps.length ? Math.round(Math.max(...dayTemps)) : null
            };
        }

        // Group hourly temperature data by day
        function groupHourlyByDay(hourly, dailyDates) {
            const result = [];
            const hours = hourly.time;
            const temps = hourly.temperature_2m;
            let dayIndex = 0;
            let currentDay = dailyDates[dayIndex];
            let dayTemps = [];
            for (let i = 0; i < hours.length; i++) {
                if (hours[i].startsWith(currentDay)) {
                    dayTemps.push(temps[i]);
                } else {
                    result.push(dayTemps);
                    dayTemps = [];
                    dayIndex++;
                    currentDay = dailyDates[dayIndex];
                    if (!currentDay) break;
                    if (hours[i].startsWith(currentDay)) {
                        dayTemps.push(temps[i]);
                    }
                }
            }
            if (dayTemps.length) result.push(dayTemps);
            return result;
        }

        // Render a mini SVG sparkline for a day's temperatures
        function renderSparkline(temps, dayIndex, tempUnit) {
            if (!temps || temps.length === 0) return '';
            const w = 60, h = 40;
            // Convert all temps for sparkline
            const convertedTemps = temps.map(t => convertTemp(t, tempUnit));
            const min = Math.min(...convertedTemps);
            const max = Math.max(...convertedTemps);
            const range = max - min || 1;
            const points = convertedTemps.map((t, i) => {
                const x = (i / (convertedTemps.length - 1)) * (w - 2) + 1;
                const y = h - 2 - ((t - min) / range) * (h - 4);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');
            // Reference lines for 0 and 20 (in selected unit)
            const y0 = h - 2 - ((convertTemp(0, tempUnit) - min) / range) * (h - 4);
            const y20 = h - 2 - ((convertTemp(20, tempUnit) - min) / range) * (h - 4);
            const gradientId = `temp-gradient-${Math.random().toString(36).substr(2, 8)}`;
            return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="vertical-align:middle;cursor:pointer;" data-day-index="${dayIndex}">
                <defs>
                    <linearGradient id="${gradientId}" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stop-color="#d32f2f"/>
                        <stop offset="50%" stop-color="#4a8e3a"/>
                        <stop offset="100%" stop-color="#1976d2"/>
                    </linearGradient>
                </defs>
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y0.toFixed(1)} ${w},${y0.toFixed(1)}" opacity="0.5" />
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y20.toFixed(1)} ${w},${y20.toFixed(1)}" opacity="0.5" />
                <polyline fill="none" stroke="url(#${gradientId})" stroke-width="2" points="${points}" />
            </svg>`;
        }

        // Render a larger SVG chart for modal
        function renderLargeTempChart(temps, tempUnit) {
            if (!temps || temps.length === 0) return '';
            const w = 340, h = 100;
            // Convert all temps for chart
            const convertedTemps = temps.map(t => convertTemp(t, tempUnit));
            const min = Math.min(...convertedTemps);
            const max = Math.max(...convertedTemps);
            const range = max - min || 1;
            const points = convertedTemps.map((t, i) => {
                const x = (i / (convertedTemps.length - 1)) * (w - 2) + 1;
                const y = h - 20 - ((t - min) / range) * (h - 40);
                return `${x.toFixed(1)},${y.toFixed(1)}`;
            }).join(' ');
            // Reference lines for 0 and 20 (in selected unit)
            const y0 = h - 20 - ((convertTemp(0, tempUnit) - min) / range) * (h - 40);
            const y20 = h - 20 - ((convertTemp(20, tempUnit) - min) / range) * (h - 40);
            const gradientId = `temp-gradient-large-${Math.random().toString(36).substr(2, 8)}`;
            const minLabel = min + getTempUnitSymbol();
            const maxLabel = max + getTempUnitSymbol();
            return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
                <defs>
                    <linearGradient id="${gradientId}" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stop-color="#d32f2f"/>
                        <stop offset="50%" stop-color="#4a8e3a"/>
                        <stop offset="100%" stop-color="#1976d2"/>
                    </linearGradient>
                </defs>
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y0.toFixed(1)} ${w},${y0.toFixed(1)}" opacity="0.5" />
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y20.toFixed(1)} ${w},${y20.toFixed(1)}" opacity="0.5" />
                <polyline fill="none" stroke="url(#${gradientId})" stroke-width="3" points="${points}" />
                <text x="2" y="${h - 22}" font-size="11" fill="#888">${minLabel}</text>
                <text x="2" y="18" font-size="11" fill="#888">${maxLabel}</text>
            </svg>`;
        }

        // Show modal with detailed chart and hourly temps
        function showWeatherModal(dayIndex, date, temps, precips, winds) {
            // Remove any existing modal
            const oldModal = document.getElementById('weatherModalOverlay');
            if (oldModal) oldModal.remove();
            // Build hourly table
            const tempUnit = tempUnitSelect.value;
            const precipUnit = precipUnitSelect.value;
            let hourlyTable = '<table class="weather-modal-hourly-table"><thead><tr><th>Hour</th><th>Temp (' + getTempUnitSymbol() + ')</th><th>Precip. (' + getPrecipUnitSymbol() + ')</th><th>Wind (km/h)</th></tr></thead><tbody>';
            for (let h = 0; h < temps.length; h++) {
                hourlyTable += `<tr><td>${h}:00</td><td>${convertTemp(temps[h], tempUnit)}</td><td>${precips && precips[h] !== undefined ? convertPrecip(precips[h], precipUnit) : '-'}</td><td>${winds && winds[h] !== undefined ? Math.round(winds[h]) : '-'}</td></tr>`;
            }
            hourlyTable += '</tbody></table>';
            // Modal HTML
            const modalHtml = `
                <div class="weather-modal-overlay" id="weatherModalOverlay" tabindex="-1">
                    <div class="weather-modal" role="dialog" aria-modal="true" aria-labelledby="weatherModalTitle">
                        <button class="weather-modal-close" id="weatherModalCloseBtn" aria-label="Close weather details">&times;</button>
                        <div class="weather-modal-title" id="weatherModalTitle">Hourly Weather for ${date}</div>
                        <div class="weather-modal-chart">${renderLargeTempChart(temps, tempUnit)}</div>
                        ${hourlyTable}
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            // Focus management
            const closeBtn = document.getElementById('weatherModalCloseBtn');
            if (closeBtn) closeBtn.focus();
            // Trap focus inside modal
            const modalOverlay = document.getElementById('weatherModalOverlay');
            const focusableSelectors = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            const modal = modalOverlay.querySelector('.weather-modal');
            const focusableEls = modal.querySelectorAll(focusableSelectors);
            const firstFocusable = focusableEls[0];
            const lastFocusable = focusableEls[focusableEls.length - 1];
            modalOverlay.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    if (focusableEls.length === 0) return;
                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            e.preventDefault();
                            lastFocusable.focus();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            e.preventDefault();
                            firstFocusable.focus();
                        }
                    }
                } else if (e.key === 'Escape') {
                    modalOverlay.remove();
                }
            });
            // Close logic
            closeBtn.onclick = () => {
                modalOverlay.remove();
            };
            modalOverlay.onclick = (e) => {
                if (e.target.id === 'weatherModalOverlay') {
                    modalOverlay.remove();
                }
            };
        }

        // Add event delegation for sparkline clicks after weather table is rendered
        function addSparklineListeners(hourlyByDay, dailyDates, hourlyPrecipByDay, hourlyWindByDay, tempUnit, precipUnit) {
            const table = document.querySelector('.weather-forecast-table');
            if (!table) return;
            table.addEventListener('click', function(e) {
                const svg = e.target.closest('svg[data-day-index]');
                if (svg) {
                    const dayIndex = parseInt(svg.getAttribute('data-day-index'));
                    if (!isNaN(dayIndex) && hourlyByDay[dayIndex]) {
                        showWeatherModal(
                            dayIndex,
                            dailyDates[dayIndex],
                            hourlyByDay[dayIndex],
                            hourlyPrecipByDay ? hourlyPrecipByDay[dayIndex] : null,
                            hourlyWindByDay ? hourlyWindByDay[dayIndex] : null
                        );
                    }
                }
            });
        }

        // On page load, check for cached location
        window.addEventListener('DOMContentLoaded', () => {
            const cached = localStorage.getItem('gardening_last_location');
            if (cached) {
                try {
                    const loc = JSON.parse(cached);
                    if (loc.type === 'query' && loc.value) {
                        locationInput.value = loc.value;
                        geocodeLocation(loc.value);
                    } else if (loc.type === 'coords' && loc.lat && loc.lon) {
                        displayLocationInfo('Your location', loc.lat, loc.lon, '', '', '');
                    }
                } catch (e) {}
            }
        });

        // Geocoding API call
        async function geocodeLocation(query, isRetry = false) {
            lastGeocodeQuery = query;
            lastWeatherAction = 'geocode';
            weatherPlaceholder.textContent = 'Looking up location...';
            // Cache the query
            localStorage.setItem('gardening_last_location', JSON.stringify({ type: 'query', value: query }));
            try {
                const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Geocoding service error');
                const data = await response.json();
                if (!data.results || data.results.length === 0) {
                    displayLocationError('Location not found. Please try a different name or postal code.', 'geocode');
                    return;
                }
                const result = data.results[0];
                displayLocationInfo(
                    result.name,
                    result.latitude,
                    result.longitude,
                    result.admin1,
                    result.admin2,
                    result.country
                );
            } catch (e) {
                displayLocationError('Could not resolve location. Please check your input and try again.', 'geocode');
            }
        }

        // Handle location input (Enter or blur)
        locationInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const query = locationInput.value.trim();
                if (query) geocodeLocation(query);
            }
        });
        locationInput.addEventListener('blur', function() {
            const query = locationInput.value.trim();
            if (query) geocodeLocation(query);
        });

        // Handle 'Use my location' button
        useMyLocationBtn.addEventListener('click', function() {
            weatherPlaceholder.textContent = 'Getting your location...';
            if (!navigator.geolocation) {
                displayLocationError('Geolocation is not supported by your browser.', 'geocode');
                return;
            }
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    const lat = pos.coords.latitude.toFixed(5);
                    const lon = pos.coords.longitude.toFixed(5);
                    // Cache the coordinates
                    localStorage.setItem('gardening_last_location', JSON.stringify({ type: 'coords', lat, lon }));
                    displayLocationInfo('Your location', lat, lon, '', '', '');
                },
                (err) => {
                    displayLocationError('Could not get your location. Please allow location access or enter a place name.', 'geocode');
                }
            );
        });

        // Unit preference logic
        const tempUnitSelect = document.getElementById('tempUnitSelect');
        const precipUnitSelect = document.getElementById('precipUnitSelect');
        // Load preferences from localStorage
        function loadUnitPrefs() {
            const temp = localStorage.getItem('gardening_temp_unit');
            const precip = localStorage.getItem('gardening_precip_unit');
            if (temp && (temp === 'C' || temp === 'F')) tempUnitSelect.value = temp;
            if (precip && (precip === 'mm' || precip === 'in')) precipUnitSelect.value = precip;
        }
        // Save preferences to localStorage
        tempUnitSelect.addEventListener('change', () => {
            localStorage.setItem('gardening_temp_unit', tempUnitSelect.value);
            if (lastWeatherData) renderWeatherData(lastWeatherData);
        });
        precipUnitSelect.addEventListener('change', () => {
            localStorage.setItem('gardening_precip_unit', precipUnitSelect.value);
            if (lastWeatherData) renderWeatherData(lastWeatherData);
        });
        // On page load, set unit preferences
        window.addEventListener('DOMContentLoaded', loadUnitPrefs);

        // Prompt Generator Logic
        const generatePromptBtn = document.getElementById('generatePromptBtn');
        const copyPromptBtn = document.getElementById('copyPromptBtn');
        const customNotes = document.getElementById('customNotes');
        const generatedPrompt = document.getElementById('generatedPrompt');
        const promptGeneratorModal = document.getElementById('promptGeneratorModal');
        const closePromptGeneratorBtn = document.getElementById('closePromptGeneratorBtn');
        const aiAdviceBtn = document.getElementById('aiAdviceBtn');
        const includeCalendar = document.getElementById('includeCalendar');
        const includeRelevantPlantsOnly = document.getElementById('includeRelevantPlantsOnly');

        // Modal handling
        function openPromptGenerator() {
            promptGeneratorModal.style.display = 'flex';
            customNotes.focus();
            // Store active element to restore focus later
            openPromptGenerator.previousActiveElement = document.activeElement;
        }

        function closePromptGenerator() {
            promptGeneratorModal.style.display = 'none';
            // Restore focus
            if (openPromptGenerator.previousActiveElement) {
                openPromptGenerator.previousActiveElement.focus();
            }
        }

        // Add event listener for the AI advice button
        aiAdviceBtn.addEventListener('click', openPromptGenerator);

        // Close modal on escape or clicking outside
        promptGeneratorModal.addEventListener('click', (e) => {
            if (e.target === promptGeneratorModal) {
                closePromptGenerator();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && promptGeneratorModal.style.display === 'flex') {
                closePromptGenerator();
            }
        });

        closePromptGeneratorBtn.addEventListener('click', closePromptGenerator);

        function isPlantSuitableForWeather(plant, weatherData) {
            // Get temperature range for next 7 days
            const next7Days = weatherData.daily.temperature_2m_max.slice(0, 7);
            const maxTemp = Math.max(...next7Days);
            const minTemp = Math.min(...weatherData.daily.temperature_2m_min.slice(0, 7));
            const avgPrecip = weatherData.daily.precipitation_sum.slice(0, 7).reduce((a, b) => a + b, 0) / 7;

            // Basic suitability rules (these could be made more sophisticated)
            const coldSensitive = ['tomato', 'pepper', 'eggplant', 'cucumber', 'zucchini', 'pumpkin', 'melon', 'basil'];
            const heatSensitive = ['lettuce', 'spinach', 'arugula', 'peas'];
            const moistureSensitive = ['tomato', 'rosemary', 'thyme', 'sage'];

            const plantLower = plant.toLowerCase();

            // Check temperature suitability
            if (coldSensitive.some(p => plantLower.includes(p)) && minTemp < 10) return false;
            if (heatSensitive.some(p => plantLower.includes(p)) && maxTemp > 30) return false;
            
            // Check moisture suitability
            if (moistureSensitive.some(p => plantLower.includes(p)) && avgPrecip > 10) return false;

            return true;
        }

        function generatePrompt() {
            // Get current location info
            let locationInfo = '';
            const weatherLocationInfo = document.querySelector('.weather-location-info');
            if (weatherLocationInfo) {
                locationInfo = weatherLocationInfo.textContent.trim();
            }

            // Get climate zone
            let climateZone = '';
            const climateZoneCode = document.getElementById('climateZoneCode');
            if (climateZoneCode) {
                climateZone = climateZoneCode.textContent.trim();
            }

            // Get current weather
            let currentWeather = '';
            const weatherCurrent = document.querySelector('.weather-current');
            if (weatherCurrent) {
                currentWeather = weatherCurrent.textContent.trim();
            }

            // Get forecast summary (next 7 days)
            let forecastSummary = '';
            const forecastTable = document.querySelector('.weather-forecast-table tbody');
            if (forecastTable) {
                const next7Days = Array.from(forecastTable.querySelectorAll('tr')).slice(0, 7);
                forecastSummary = next7Days.map(row => {
                    const cells = row.querySelectorAll('td');
                    return `- ${cells[0].textContent}:\n  ${cells[6].textContent.split('\n')[1]}\n  Max: ${cells[4].textContent}, Precipitation: ${cells[5].textContent}`;
                }).join('\n\n');
            }

            // Get current month's planting calendar with only selected items
            let plantingCalendar = '';
            if (includeCalendar.checked) {
                const selections = getSelectedItems();
                const currentSelections = selections[activeMonth];
                
                if (currentSelections && Object.keys(currentSelections).length > 0) {
                    const plantItems = [];
                    Object.entries(currentSelections).forEach(([category, items]) => {
                        if (items.length > 0) {
                            const filteredItems = items.filter(item => {
                                if (!includeRelevantPlantsOnly.checked || !lastWeatherData) return true;
                                return isPlantSuitableForWeather(item, lastWeatherData);
                            });
                            if (filteredItems.length > 0) {
                                plantItems.push(`${categoryNames[category] || category}:\n${filteredItems.join('\n')}`);
                            }
                        }
                    });
                    if (plantItems.length > 0) {
                        plantingCalendar = 'Selected Plants and Tasks:\n\n' + plantItems.join('\n\n');
                    }
                }

                // If no selections, add a note
                if (!plantingCalendar) {
                    plantingCalendar = 'No plants or tasks selected yet. Please check items in the calendar that interest you.\n';
                }
            }

            // Get user's custom notes
            const notes = customNotes.value.trim();

            // Construct the prompt
            const prompt = `I need advice for my garden based on the following information:

Location and Climate:
${locationInfo}

Köppen Climate Zone: ${climateZone}
${includeRelevantPlantsOnly.checked ? '(Recommendations filtered for current weather conditions)' : ''}

Current Weather and Forecast:
${currentWeather}

7-Day Forecast:
${forecastSummary}

${plantingCalendar}

${notes ? `Additional Notes:\n${notes}\n\n` : ''}Based on this information, please provide:
1. Immediate tasks I should focus on this week
2. What I should plant now or prepare for planting
3. Potential weather-related precautions
4. Long-term planning suggestions
5. Any specific care instructions for my selected plants

Please be specific and consider the weather forecast and climate zone in your recommendations.`;

            generatedPrompt.textContent = prompt;
        }

        function copyPrompt() {
            navigator.clipboard.writeText(generatedPrompt.textContent)
                .then(() => {
                    const originalText = copyPromptBtn.textContent;
                    copyPromptBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyPromptBtn.textContent = originalText;
                    }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy text:', err);
                    alert('Failed to copy to clipboard. Please select and copy the text manually.');
                });
        }

        generatePromptBtn.addEventListener('click', generatePrompt);
        copyPromptBtn.addEventListener('click', copyPrompt);

        // Don't automatically generate on weather update anymore since it's in a modal
        const originalRenderWeatherData = renderWeatherData;
        renderWeatherData = function(data) {
            originalRenderWeatherData.call(this, data);
        };

        // Selection storage functionality
        function getSelectedItems() {
            const stored = localStorage.getItem('gardening_selected_items');
            return stored ? JSON.parse(stored) : {};
        }

        function isItemSelected(month, category, item) {
            const selections = getSelectedItems();
            return selections[month]?.[category]?.includes(item) || false;
        }

        function toggleItemSelection(month, category, item, selected) {
            const selections = getSelectedItems();
            
            // Initialize nested structure if needed
            if (!selections[month]) selections[month] = {};
            if (!selections[month][category]) selections[month][category] = [];
            
            const items = selections[month][category];
            const index = items.indexOf(item);
            
            if (selected && index === -1) {
                items.push(item);
            } else if (!selected && index !== -1) {
                items.splice(index, 1);
            }
            
            // Clean up empty arrays and objects
            if (items.length === 0) delete selections[month][category];
            if (Object.keys(selections[month]).length === 0) delete selections[month];
            
            localStorage.setItem('gardening_selected_items', JSON.stringify(selections));
        }
    </script>
</body>
</html> 