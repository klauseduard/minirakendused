<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZFD132PZ0Z"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        
        gtag('config', 'G-ZFD132PZ0Z', {
            'page_path': '/minirakendused/gardening_calendar'
        });
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Gardening and Planting Calendar</title>
    <style>
        :root {
            --primary-color: #4a8e3a;
            --secondary-color: #8bc34a;
            --accent-color: #3e7d32;
            --light-bg: #f1f8e9;
            --dark-bg: #e8f5e9;
            --white: #ffffff;
            --black: #212121;
            --shadow: rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--light-bg);
            color: var(--black);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin: -20px -20px 20px -20px;  /* Negative margin to span full width */
            padding: 15px 20px;
            background-color: var(--primary-color);
            color: var(--white);
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 8px var(--shadow);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        /* Add transition for smooth shadow change on scroll */
        header.scrolled {
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        /* Compact header on scroll */
        header.scrolled h1 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .description {
            font-size: 1rem;
            font-weight: 400;
            color: #224c2a;
            margin: 0 auto;
            max-width: 700px;
        }
        
        .main-layout {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .top-controls {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .location-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        .units-row {
            display: flex;
            gap: 25px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            background: var(--light-bg);
            padding: 15px;
            border-radius: 8px;
        }

        .unit-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .unit-group label {
            font-weight: 500;
            color: var(--primary-color);
        }
        
        .unit-group select {
            padding: 8px 12px;
            border: 2px solid var(--secondary-color);
            border-radius: 20px;
            background-color: var(--white);
            color: var(--black);
            font-size: 0.95rem;
            outline: none;
            cursor: pointer;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        
        .unit-group select:hover {
            border-color: var(--accent-color);
        }
        
        .unit-group select:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(62, 125, 50, 0.2);
        }

        .weather-display {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .search-bar {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .search-section-title {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 500;
        }

        .search-container {
            width: 100%;
        }

        .search-box {
            width: 100%;
            padding: 12px 20px;
            font-size: 1rem;
            border: 2px solid var(--secondary-color);
            border-radius: 30px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .search-box:focus {
            border-color: var(--primary-color);
        }

        .month-navigation {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 25px;
        }

        .month-nav-title {
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 500;
        }

        .calendar-nav {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .month-btn, .location-action-btn {
            padding: 12px 25px;
            background-color: var(--secondary-color);
            color: var(--white);
            border: none;
            border-radius: 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px var(--shadow);
            min-width: 120px;
            text-align: center;
        }

        .month-btn:hover, .location-action-btn:hover {
            background-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .month-btn.active {
            background-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow);
        }

        .scroll-indicator {
            text-align: center;
            padding: 15px;
            color: var(--primary-color);
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            margin-bottom: 25px;
        }

        .scroll-indicator:hover {
            transform: translateY(2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .scroll-indicator-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .scroll-indicator-text {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--primary-color);
        }

        .scroll-arrow {
            font-size: 1.5rem;
            animation: bounce 2s infinite;
            color: var(--secondary-color);
        }

        .scroll-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--secondary-color);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px var(--shadow);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            transform: translateY(20px);
            z-index: 100;
            border: none;
        }

        .scroll-to-top.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .scroll-to-top:hover {
            background: var(--accent-color);
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0;  /* Remove padding on mobile */
            }

            header {
                margin: 0;  /* Remove negative margins on mobile */
                padding: 10px;
            }

            header.scrolled {
                padding: 8px;
            }

            h1 {
                font-size: 1.6rem;
                margin-bottom: 12px;
            }

            header.scrolled h1 {
                font-size: 1.3rem;
                margin-bottom: 8px;
            }

            .quick-jump-menu {
                padding: 8px;
                gap: 6px;
            }
            
            .quick-jump-btn {
                padding: 6px 12px;
                font-size: 0.9rem;
                min-width: calc(50% - 6px);
            }

            header.scrolled .quick-jump-btn {
                padding: 4px 10px;
                font-size: 0.85rem;
            }
        }

        .calendar-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .category-card {
            background-color: var(--white);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px var(--shadow);
            transition: transform 0.3s ease;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .category-card:last-child {
            grid-column: 1 / -1;
        }

        .garden-tasks-card {
            grid-column: 1 / -1;
        }
        
        .category-card .plant-list {
            flex-grow: 1;
        }
        
        .category-card:hover {
            transform: translateY(-5px);
        }
        
        .category-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .category-icon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
            background-color: var(--secondary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-size: 1.2rem;
        }
        
        .category-title {
            font-size: 1.3rem;
            color: var(--primary-color);
        }
        
        .plant-list {
            list-style-type: none;
        }
        
        .plant-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
        }
        
        .plant-item:last-child {
            border-bottom: none;
        }
        
        .plant-item::before {
            content: "üå±";
            margin-right: 10px;
        }
        
        .task-item {
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
        }
        
        .task-item:last-child {
            border-bottom: none;
        }
        
        .task-item::before {
            content: "‚úì";
            margin-right: 10px;
        }
        
        .item-label {
            width: 100%;
            padding: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .item-label:hover {
            background: var(--light-bg);
        }

        .item-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary-color);
            margin: 0;
        }

        .item-text {
            flex: 1;
            padding: 2px 0;
        }
        
        .highlight {
            background-color: #ffe066;
            padding: 2px;
            border-radius: 3px;
        }
        
        .no-results {
            text-align: center;
            padding: 20px;
            font-size: 1.2rem;
            color: #757575;
            grid-column: 1 / -1;
        }
        
        .mobile-warning {
            display: none;
            text-align: center;
            padding: 10px;
            background-color: #fff3e0;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: static;
            }

            .action-bar {
                flex-direction: column;
            }

            .search-container {
                width: 100%;
            }

            .ai-advice-btn {
                width: 100%;
                justify-content: center;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease forwards;
        }
        
        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #757575;
            font-size: 0.9rem;
        }
        
        .weather-section {
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 8px var(--shadow);
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 15px;
        }
        
        .weather-location-row {
            margin-bottom: 10px;
        }
        
        .weather-location-info {
            margin-bottom: 18px;
            font-size: 1.08em;
        }
        
        .weather-forecast-table {
            width: 100%;
            font-size: 0.97em;
            margin-top: 10px;
            border-collapse: separate;
            border-spacing: 0 6px;
            background: #f8faf5;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 4px rgba(74,142,58,0.07);
        }
        
        .weather-forecast-table th, .weather-forecast-table td {
            padding: 7px 14px;
            text-align: center;
        }
        
        .weather-forecast-table th {
            background: #e8f5e9;
            color: #3e7d32;
            font-weight: 600;
            border-bottom: 2px solid #c8e6c9;
        }
        
        .weather-forecast-table td {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .weather-forecast-table tr:last-child td {
            border-bottom: none;
        }
        
        .weather-forecast-table td svg {
            display: block;
            margin: 0 auto;
            cursor: pointer;
        }
        
        .weather-current {
            margin-bottom: 10px;
            font-size: 1.08em;
        }
        
        .location-input {
            padding: 10px 16px;
            border: 2px solid var(--secondary-color);
            border-radius: 30px;
            font-size: 1rem;
            outline: none;
            width: 100%;
            box-sizing: border-box;
        }
        
        .location-input-group {
            position: relative;
            display: flex;
            align-items: center;
            flex: 1;  /* Take most of the space */
            min-width: 200px;
        }
        
        .search-location-btn {
            white-space: nowrap;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .geo-location-btn {
            white-space: nowrap;
            min-width: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .search-icon, .location-icon {
            font-size: 1.1em;
        }
        
        .location-clear-btn {
            position: absolute;
            right: 15px;
            background: none;
            border: none;
            cursor: pointer;
            color: #999;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            opacity: 0.7;
        }
        
        .location-clear-btn:hover {
            background-color: rgba(0,0,0,0.05);
            color: #666;
        }
        
        .location-btn {
            padding: 10px 18px;
            background-color: var(--secondary-color);
            color: var(--white);
            border: none;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .location-btn:hover {
            background-color: var(--accent-color);
        }
        
        .weather-placeholder {
            color: #333;
            font-size: 1.1rem;
        }
        
        /* Modal for detailed weather */
        .weather-modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.25);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .weather-modal {
            background: var(--light-bg);
            border-radius: 14px;
            box-shadow: 0 4px 24px var(--shadow);
            padding: 28px 32px 24px 32px;
            min-width: 340px;
            max-width: 95vw;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .weather-modal-close {
            position: absolute;
            top: 10px;
            right: 16px;
            font-size: 1.4em;
            color: #7cb342;
            background: none;
            border: none;
            cursor: pointer;
            transition: color 0.2s;
        }
        .weather-modal-close:hover {
            color: #388e3c;
        }
        .weather-modal-title {
            font-size: 1.18em;
            margin-bottom: 18px;
            color: var(--primary-color);
            font-weight: 600;
            letter-spacing: 0.01em;
        }
        .weather-modal-chart {
            margin-bottom: 18px;
            background: var(--white);
            border-radius: 10px;
            box-shadow: 0 1px 4px var(--shadow);
            padding: 12px 8px 8px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .weather-modal-hourly-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 4px;
            font-size: 0.98em;
            background: #f8faf5;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 4px rgba(74,142,58,0.07);
            margin-top: 8px;
        }
        .weather-modal-hourly-table th, .weather-modal-hourly-table td {
            padding: 6px 12px;
            text-align: center;
        }
        .weather-modal-hourly-table th {
            background: #e8f5e9;
            color: #3e7d32;
            font-weight: 600;
        }
        .weather-modal-hourly-table td {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
        }
        .weather-modal-hourly-table tr:last-child td {
            border-bottom: none;
        }
        .weather-forecast-table tr:nth-child(even) td,
        .weather-modal-hourly-table tr:nth-child(even) td {
            background: #f1f8e9;
        }
        /* Visually hidden class for accessibility */
        .visually-hidden {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }

        /* AI Assistants Grid Styles */
        .ai-assistants-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .ai-assistant-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 15px 10px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .ai-assistant-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
            border-color: var(--secondary-color);
        }

        .ai-assistant-btn:active {
            transform: translateY(0);
        }

        .ai-logo {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .ai-assistant-btn span {
            font-weight: 500;
            color: #333;
        }

        @media (max-width: 600px) {
            .ai-assistants-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .month-btn:focus, .location-btn:focus, .weather-modal-close:focus {
            outline: 3px solid #1976d2 !important;
            outline-offset: 2px;
        }
        .item-label {
            width: 100%;
            padding: 4px 0;
        }
        .item-label:hover {
            background: var(--light-bg);
        }
        .item-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary-color);
        }
        .item-text {
            flex: 1;
        }
        .quick-jump-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 15px;
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .quick-jump-title {
            width: 100%;
            text-align: center;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 5px;
            font-weight: 500;
        }

        .quick-jump-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            min-width: 0;
            justify-content: center;
        }

        .nav-icon {
            font-size: 1.2em;
            display: inline-block;
        }

        .quick-jump-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .quick-jump-btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
        }

        .quick-jump-btn.active {
            background: white;
            color: var(--primary-color);
            border-color: white;
        }

        @media (max-width: 799px) {
            header {
                padding: 10px;
                top: 0;
                border-radius: 0;
                margin: -20px -20px 20px -20px;
                width: calc(100% + 40px);
            }

            h1 {
                font-size: 1.6rem;
                margin-bottom: 12px;
            }

            .quick-jump-menu {
                padding: 8px;
                gap: 6px;
            }
            
            .quick-jump-btn {
                padding: 6px 8px;
                font-size: 0.85rem;
                flex: 0 0 calc(50% - 3px);
            }

            .nav-icon {
                font-size: 1.1em;
            }
        }

        .ai-icon {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .location-row {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .location-row {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }
            
            .search-location-btn,
            .geo-location-btn {
                width: 100%;
                min-width: 0;
            }
            
            .units-row {
                padding: 12px;
                gap: 15px;
                justify-content: space-between;
            }
            
            .unit-group {
                flex-basis: calc(50% - 10px);
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .unit-group select {
                width: 100%;
            }
            
            .search-bar {
                flex-direction: column;
            }
            
            .search-container {
                width: 100%;
            }
            
            .ai-advice-btn {
                width: 100%;
            }
            
            .mobile-warning {
                display: block;
            }
        }

        .category-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .select-all-container {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 6px 10px;
            background-color: var(--light-bg);
            border-radius: 6px;
        }
        
        .select-all-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 500;
            color: var(--primary-color);
        }
        
        .select-all-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Spring Gardening and Planting Calendar</h1>
            <div class="quick-jump-menu" id="quickJumpMenu">
                <div class="quick-jump-title">Quick Navigation:</div>
                <button class="quick-jump-btn" data-section="location-setup">
                    <span class="nav-icon">üìç</span> Location
                </button>
                <button class="quick-jump-btn" data-section="weather-info">
                    <span class="nav-icon">üå§Ô∏è</span> Weather
                </button>
                <button class="quick-jump-btn" data-section="search-section">
                    <span class="nav-icon">ü§ñ</span> Search & AI
                </button>
                <button class="quick-jump-btn" data-section="monthly-calendar">
                    <span class="nav-icon">üìÖ</span> Calendar
                </button>
                <button class="quick-jump-btn" data-section="garden-journal">
                    <span class="nav-icon">üìî</span> Journal
                </button>
            </div>
        </header>

        <main class="main-layout">
            <!-- Location and Units Controls -->
            <section class="top-controls" id="location-setup">
                <div class="location-row">
                    <div class="location-input-group">
                        <label for="locationInput" class="visually-hidden">Location</label>
                        <input type="text" class="location-input" id="locationInput" 
                            placeholder="City or place name (e.g., Paris, Barcelona)" 
                            aria-label="Location">
                        <button type="button" id="clearLocationBtn" class="location-clear-btn" 
                            aria-label="Clear location">√ó</button>
                    </div>
                    <button class="location-action-btn search-location-btn" id="searchLocationBtn">
                        <span class="search-icon">üîç</span> Search
                    </button>
                    <button class="location-action-btn geo-location-btn" id="useMyLocationBtn">
                        <span class="location-icon">üìç</span> My Location
                    </button>
                </div>
                <div class="units-row">
                    <div class="unit-group">
                        <label for="tempUnitSelect">Temperature:</label>
                        <select id="tempUnitSelect" aria-label="Temperature unit">
                            <option value="C">Celsius (¬∞C)</option>
                            <option value="F">Fahrenheit (¬∞F)</option>
                        </select>
                    </div>
                    <div class="unit-group">
                        <label for="precipUnitSelect">Precipitation:</label>
                        <select id="precipUnitSelect" aria-label="Precipitation unit">
                            <option value="mm">Millimeters (mm)</option>
                            <option value="in">Inches (in)</option>
                        </select>
                    </div>
                </div>
                <div id="climateZoneInfo"></div>
            </section>

            <!-- Weather Display -->
            <section class="weather-display" id="weather-info">
                <div class="weather-placeholder" id="weatherPlaceholder">
                    Weather information for your location will appear here.
                </div>
            </section>

            <!-- Search Bar -->
            <section class="search-bar" id="search-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 class="search-section-title">Search & AI Garden Assistant</h2>
                    <button id="aiAdviceBtn" class="ai-advice-btn" style="padding: 8px 16px; background: var(--secondary-color); color: white; border: none; border-radius: 20px; display: flex; align-items: center; gap: 8px; font-weight: 500; cursor: pointer; transition: background-color 0.3s;">
                        <span style="font-size: 1.2em;">ü§ñ</span>
                        <span>Generate AI gardening advice prompt</span>
                    </button>
                </div>
                <div class="search-container">
                    <label for="searchBox" class="visually-hidden">Search for plants or tasks</label>
                    <input type="text" class="search-box" id="searchBox" 
                        placeholder="Type to search for specific plants or garden tasks..." 
                        aria-label="Search for plants or tasks">
                </div>
            </section>

            <!-- Month Navigation -->
            <section class="month-navigation" id="monthly-calendar">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 class="month-nav-title">Select Growing Period</h2>
                </div>
                <div class="calendar-nav">
                    <button class="month-btn active" data-month="april">April</button>
                    <button class="month-btn" data-month="may">May</button>
                    <button class="month-btn" data-month="early_june">Early June</button>
                </div>
            </section>

            <!-- Calendar Content -->
            <section class="calendar-content" id="calendarContent">
                <!-- Content will be added by JavaScript -->
            </section>

            <!-- Garden Journal Section -->
            <section class="garden-journal" id="garden-journal" style="display: none;">
                <div class="journal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 class="journal-title" style="color: var(--primary-color); font-size: 1.4rem;">Garden Journal</h2>
                    <div style="display: flex; gap: 10px;">
                        <button id="exportJournalBtn" class="journal-btn" style="padding: 8px 12px; background: var(--primary-color); color: white; border: none; border-radius: 20px; display: flex; align-items: center; gap: 5px; font-weight: 500; cursor: pointer; transition: background-color 0.3s;">
                            <span style="font-size: 1.1em;">üì§</span>
                            <span>Export</span>
                        </button>
                        <button id="importJournalBtn" class="journal-btn" style="padding: 8px 12px; background: var(--primary-color); color: white; border: none; border-radius: 20px; display: flex; align-items: center; gap: 5px; font-weight: 500; cursor: pointer; transition: background-color 0.3s;">
                            <span style="font-size: 1.1em;">üì•</span>
                            <span>Import</span>
                        </button>
                        <button id="addJournalEntryBtn" class="journal-add-btn" style="padding: 8px 12px; background: var(--secondary-color); color: white; border: none; border-radius: 20px; display: flex; align-items: center; gap: 5px; font-weight: 500; cursor: pointer; transition: background-color 0.3s;">
                            <span style="font-size: 1.1em;">‚ûï</span>
                            <span>New Entry</span>
                        </button>
                    </div>
                </div>
                
                <div class="journal-tabs" style="display: flex; gap: 12px; margin-bottom: 20px;">
                    <button class="journal-tab active" data-view="timeline" style="padding: 8px 16px; background: var(--white); border: 2px solid var(--secondary-color); border-radius: 20px; font-weight: 500; cursor: pointer;">Timeline</button>
                    <button class="journal-tab" data-view="gallery" style="padding: 8px 16px; background: var(--white); border: 2px solid var(--secondary-color); border-radius: 20px; font-weight: 500; cursor: pointer;">Photo Gallery</button>
                    <button class="journal-tab" data-view="calendar" style="padding: 8px 16px; background: var(--white); border: 2px solid var(--secondary-color); border-radius: 20px; font-weight: 500; cursor: pointer;">Calendar</button>
                </div>
                
                <div id="journalContent" class="journal-content" style="background: var(--white); border-radius: 10px; padding: 20px; box-shadow: 0 2px 8px var(--shadow);">
                    <!-- Will be populated by JavaScript -->
                    <div id="emptyJournalMessage" style="text-align: center; padding: 40px 20px;">
                        <div style="font-size: 3rem; margin-bottom: 20px;">üìî</div>
                        <h3 style="margin-bottom: 15px; color: var(--primary-color);">Your Garden Journal is Empty</h3>
                        <p style="margin-bottom: 20px; color: #666;">Start documenting your gardening journey by adding your first entry!</p>
                        <button id="emptyJournalAddBtn" class="journal-add-btn" style="padding: 10px 20px; background: var(--secondary-color); color: white; border: none; border-radius: 20px; font-weight: 500; cursor: pointer; display: inline-flex; align-items: center; gap: 8px;">
                            <span>‚ûï</span> Add First Entry
                        </button>
                    </div>
                    
                    <div id="journalTimeline" style="display: none;">
                        <!-- Timeline entries will be added here -->
                    </div>
                    
                    <div id="journalGallery" style="display: none;">
                        <!-- Photo gallery will be added here -->
                    </div>
                    
                    <div id="journalCalendar" style="display: none;">
                        <!-- Calendar view will be added here -->
                    </div>
                </div>
            </section>

            <button class="scroll-to-top" id="scrollToTop" aria-label="Scroll to top" style="display: none;">
                ‚Üë
            </button>
        </main>

        <!-- Prompt Generator Modal -->
        <div id="promptGeneratorModal" class="weather-modal-overlay" style="display: none;">
            <div class="weather-modal" style="width: 90%; max-width: 800px;">
                <button class="weather-modal-close" id="closePromptGeneratorBtn" aria-label="Close prompt generator">&times;</button>
                <div class="weather-modal-title">AI Gardening Assistant</div>
                <div style="margin: 20px 0;">
                    <p style="margin-bottom: 15px; color: #666;">
                        This tool will generate a comprehensive prompt based on your location, weather, and garden information. 
                        You can use this prompt with any AI assistant to get personalized gardening advice.
                    </p>
                    <div style="margin-bottom: 15px;">
                        <label for="customNotes" style="display: block; margin-bottom: 8px; font-weight: 500;">Your notes about your garden:</label>
                        <textarea id="customNotes" rows="4" style="width: 100%; padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; margin-bottom: 10px;" placeholder="Describe your garden's current state, what you've already done, or ask specific questions..."></textarea>
                    </div>
                    <div style="margin-bottom: 15px; padding: 12px; background: #fff3e0; border-radius: 8px;">
                        <h3 style="margin-bottom: 10px; color: #e65100; font-size: 1rem;">Include in Prompt:</h3>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="display: block;">
                                <input type="checkbox" id="includeCalendar" checked>
                                Selected plants and tasks
                                <span style="margin-left: 5px; color: #666; font-size: 0.9em;">
                                    (Your checked items from the planting calendar)
                                </span>
                            </label>
                            <label style="display: block;">
                                <input type="checkbox" id="includeRelevantPlantsOnly" checked>
                                Filter for weather conditions
                                <span style="margin-left: 5px; color: #666; font-size: 0.9em;">
                                    (Only include plants suitable for current forecast)
                                </span>
                            </label>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button id="generatePromptBtn" class="location-btn">Generate Prompt</button>
                        <button id="copyPromptBtn" class="location-btn" style="background: var(--accent-color);">Copy to Clipboard</button>
                    </div>
                    <div id="generatedPrompt" style="background: #f8faf5; border-radius: 8px; padding: 15px; white-space: pre-wrap; font-family: monospace; max-height: 400px; overflow-y: auto;">
                        Click "Generate Prompt" to create a customized gardening prompt based on your location, weather, and calendar data.
                    </div>
                    
                    <!-- AI Assistants Integration -->
                    <div id="promptDestinationSection" style="margin-top: 20px; display: none;">
                        <h3 style="margin-bottom: 15px; font-size: 1.1rem; color: var(--primary-color);">Send Prompt Directly To:</h3>
                        <div class="ai-assistants-grid">
                            <button class="ai-assistant-btn" data-assistant="chatgpt">
                                <div class="ai-icon" style="background-color: #10a37f; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                                    </svg>
                                </div>
                                <span>ChatGPT</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="claude">
                                <div class="ai-icon" style="background-color: #9A5CF2; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M12 16v-4"></path>
                                        <path d="M12 8h.01"></path>
                                    </svg>
                                </div>
                                <span>Claude</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="gemini">
                                <div class="ai-icon" style="background-color: #1E88E5; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                                    </svg>
                                </div>
                                <span>Gemini</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="copilot">
                                <div class="ai-icon" style="background-color: #0F6CBD; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M9 18l6-6-6-6"></path>
                                    </svg>
                                </div>
                                <span>Copilot</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="mistral">
                                <div class="ai-icon" style="background-color: #DE5833; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M20 12V8H6a2 2 0 1 1 0-4h12v4"></path>
                                        <path d="M4 12v4h14a2 2 0 1 1 0 4H4v-4"></path>
                                    </svg>
                                </div>
                                <span>Mistral</span>
                            </button>
                            <button class="ai-assistant-btn" data-assistant="deepseek">
                                <div class="ai-icon" style="background-color: #1B7A9F; color: white; border-radius: 8px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="5"></circle>
                                        <line x1="12" y1="1" x2="12" y2="3"></line>
                                        <line x1="12" y1="21" x2="12" y2="23"></line>
                                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                                        <line x1="1" y1="12" x2="3" y2="12"></line>
                                        <line x1="21" y1="12" x2="23" y2="12"></line>
                                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                                    </svg>
                                </div>
                                <span>DeepSeek</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Journal Entry Modal -->
        <div id="journalEntryModal" class="weather-modal-overlay" style="display: none;">
            <div class="weather-modal" style="width: 90%; max-width: 800px;">
                <button class="weather-modal-close" id="closeJournalEntryBtn" aria-label="Close journal entry">&times;</button>
                <div class="weather-modal-title" id="journalEntryModalTitle">Add Journal Entry</div>
                <div style="margin: 20px 0;">
                    <form id="journalEntryForm">
                        <input type="hidden" id="journalEntryId">
                        
                        <div style="margin-bottom: 20px;">
                            <label for="entryDate" style="display: block; margin-bottom: 8px; font-weight: 500;">Date:</label>
                            <input type="date" id="entryDate" style="padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; width: 100%;" required>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label for="entryType" style="display: block; margin-bottom: 8px; font-weight: 500;">Entry Type:</label>
                            <select id="entryType" style="padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; width: 100%;" required>
                                <option value="planting">üå± Planting</option>
                                <option value="care">üåø Garden Care</option>
                                <option value="harvest">ü•ï Harvest</option>
                                <option value="observation">üëÅÔ∏è Observation</option>
                                <option value="maintenance">üß∞ Maintenance</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label for="entryLocation" style="display: block; margin-bottom: 8px; font-weight: 500;">Location in Garden:</label>
                            <input type="text" id="entryLocation" style="padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; width: 100%;" placeholder="e.g., North bed, Container #3">
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label for="entryPlants" style="display: block; margin-bottom: 8px; font-weight: 500;">Plants:</label>
                            <select id="entryPlants" style="padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; width: 100%;" multiple>
                                <!-- Will be populated from the calendar data -->
                            </select>
                            <div style="margin-top: 8px; font-size: 0.9em; color: #666;">
                                Hold Ctrl/Cmd to select multiple plants
                            </div>
                        </div>
                        
                        <div id="harvestMetricsContainer" style="margin-bottom: 20px; display: none;">
                            <h4 style="margin-bottom: 12px; color: var(--primary-color);">Harvest Metrics</h4>
                            
                            <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                                <div style="flex: 1;">
                                    <label for="harvestQuantity" style="display: block; margin-bottom: 8px; font-weight: 500;">Quantity:</label>
                                    <input type="number" id="harvestQuantity" min="0" step="0.1" style="padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; width: 100%;" placeholder="e.g., 2.5">
                                </div>
                                <div style="flex: 1;">
                                    <label for="harvestUnit" style="display: block; margin-bottom: 8px; font-weight: 500;">Unit:</label>
                                    <select id="harvestUnit" style="padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px; width: 100%;">
                                        <option value="kg">Kilograms (kg)</option>
                                        <option value="lb">Pounds (lb)</option>
                                        <option value="g">Grams (g)</option>
                                        <option value="oz">Ounces (oz)</option>
                                        <option value="count">Count (pieces)</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div>
                                <label for="harvestQuality" style="display: block; margin-bottom: 8px; font-weight: 500;">Quality Rating:</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="range" id="harvestQuality" min="1" max="5" value="3" style="flex: 1;">
                                    <span id="qualityRatingText">Good</span>
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label for="entryNotes" style="display: block; margin-bottom: 8px; font-weight: 500;">Notes:</label>
                            <textarea id="entryNotes" rows="4" style="width: 100%; padding: 10px; border: 1px solid var(--secondary-color); border-radius: 8px;" placeholder="Describe what you did, observed, or harvested..."></textarea>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 500;">Photos:</label>
                            <div id="photoUploadContainer" style="border: 2px dashed var(--secondary-color); border-radius: 8px; padding: 20px; text-align: center;">
                                <div id="dragDropText">
                                    <div style="font-size: 2rem; margin-bottom: 10px;">üì∑</div>
                                    <p>Drag and drop photos here or <label for="photoInput" style="color: var(--primary-color); cursor: pointer;">browse</label></p>
                                </div>
                                <input type="file" id="photoInput" accept="image/*" multiple style="display: none;">
                                <div id="photoPreviewContainer" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px;"></div>
                            </div>
                            <div id="storageWarning" style="margin-top: 8px; font-size: 0.9em; color: #f57c00; display: none;">
                                Storage usage is high. Consider removing some photos or exporting your journal.
                            </div>
                            <div style="margin-top: 8px; font-size: 0.9em; color: #666;">
                                Photos will be automatically resized to save storage space. Maximum 5 photos per entry.
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button type="button" id="cancelJournalEntryBtn" style="padding: 10px 20px; background: #e0e0e0; color: #333; border: none; border-radius: 20px; font-weight: 500; cursor: pointer;">Cancel</button>
                            <button type="submit" id="saveJournalEntryBtn" style="padding: 10px 20px; background: var(--primary-color); color: white; border: none; border-radius: 20px; font-weight: 500; cursor: pointer;">Save Entry</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <footer>
            <p>Spring Gardening and Planting Calendar ¬© 2025</p>
        </footer>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="customConfirmModal" class="weather-modal-overlay" style="display: none; z-index: 1000;">
        <div class="weather-modal" style="max-width: 450px; padding: 25px;">
            <div id="confirmModalTitle" style="font-size: 1.2rem; font-weight: 600; color: var(--primary-color); margin-bottom: 15px;">Confirm Action</div>
            <div id="confirmModalMessage" style="margin-bottom: 25px; line-height: 1.5;">Message goes here</div>
            <div style="display: flex; justify-content: flex-end; gap: 12px;">
                <button id="confirmModalCancelBtn" class="button" style="background: #e0e0e0; color: #333; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer;">Cancel</button>
                <button id="confirmModalOkBtn" class="button" style="background: var(--primary-color); color: white; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer;">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Export Options Modal -->
    <div id="exportOptionsModal" class="weather-modal-overlay" style="display: none; z-index: 1000;">
        <div class="weather-modal" style="max-width: 450px; padding: 25px;">
            <button class="weather-modal-close" id="exportModalCloseBtn" aria-label="Close export options">&times;</button>
            <div style="font-size: 1.2rem; font-weight: 600; color: var(--primary-color); margin-bottom: 15px;">Export Options</div>
            <div style="margin-bottom: 25px; line-height: 1.5;">Choose how you would like to export your journal:</div>
            
            <div class="export-option" style="display: flex; align-items: center; padding: 12px; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 12px; cursor: pointer;">
                <div style="margin-right: 15px; font-size: 1.5rem;">üì∑</div>
                <div style="flex-grow: 1;">
                    <div style="font-weight: 500;">Complete Export</div>
                    <div style="font-size: 0.9rem; color: #666;">Include all entries with images (larger file size)</div>
                </div>
            </div>
            
            <div class="export-option" style="display: flex; align-items: center; padding: 12px; border: 1px solid #ddd; border-radius: 8px; cursor: pointer;">
                <div style="margin-right: 15px; font-size: 1.5rem;">üìù</div>
                <div style="flex-grow: 1;">
                    <div style="font-weight: 500;">Lightweight Export</div>
                    <div style="font-size: 0.9rem; color: #666;">Text-only export without images (smaller file size)</div>
                </div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-top: 20px;">
                <button id="exportOptionsCancelBtn" class="button" style="background: #e0e0e0; color: #333; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer; margin-right: 12px;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Import Options Modal -->
    <div id="importOptionsModal" class="weather-modal-overlay" style="display: none; z-index: 1000;">
        <div class="weather-modal" style="max-width: 450px; padding: 25px;">
            <button class="weather-modal-close" id="importModalCloseBtn" aria-label="Close import options">&times;</button>
            <div style="font-size: 1.2rem; font-weight: 600; color: var(--primary-color); margin-bottom: 15px;">Import Options</div>
            <div id="importStatsMessage" style="margin-bottom: 25px; line-height: 1.5;">Found entries to import.</div>
            
            <div class="import-option" style="display: flex; align-items: center; padding: 12px; border: 1px solid #ddd; border-radius: 8px; margin-bottom: 12px; cursor: pointer;">
                <div style="margin-right: 15px; font-size: 1.5rem;">üîÑ</div>
                <div style="flex-grow: 1;">
                    <div style="font-weight: 500;">Merge</div>
                    <div style="font-size: 0.9rem; color: #666;">Add new entries and update existing ones</div>
                </div>
            </div>
            
            <div class="import-option" style="display: flex; align-items: center; padding: 12px; border: 1px solid #ddd; border-radius: 8px; cursor: pointer;">
                <div style="margin-right: 15px; font-size: 1.5rem;">‚ôªÔ∏è</div>
                <div style="flex-grow: 1;">
                    <div style="font-weight: 500;">Replace All</div>
                    <div style="font-size: 0.9rem; color: #666;">Delete all existing entries and use imported ones</div>
                </div>
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-top: 20px;">
                <button id="importOptionsCancelBtn" class="button" style="background: #e0e0e0; color: #333; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div id="deleteConfirmModal" class="weather-modal-overlay" style="display: none; z-index: 1000;">
        <div class="weather-modal" style="max-width: 450px; padding: 25px;">
            <button class="weather-modal-close" id="deleteModalCloseBtn" aria-label="Close delete confirmation">&times;</button>
            <div style="font-size: 1.2rem; font-weight: 600; color: #d32f2f; margin-bottom: 15px;">Delete Entry</div>
            <div style="margin-bottom: 25px; line-height: 1.5;">Are you sure you want to delete this journal entry? This action cannot be undone.</div>
            <div style="display: flex; justify-content: flex-end; gap: 12px;">
                <button id="deleteConfirmCancelBtn" class="button" style="background: #e0e0e0; color: #333; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer;">Cancel</button>
                <button id="deleteConfirmBtn" class="button" style="background: #d32f2f; color: white; padding: 8px 16px; border: none; border-radius: 20px; cursor: pointer;">Delete</button>
            </div>
        </div>
    </div>

    <!-- Image viewer modal -->
    <!-- ... existing code ... -->

    <script>
        // Multi-language support
        const translations = {
            'en': {
                // Header
                'title': 'Spring Gardening and Planting Calendar',
                'quick_nav': 'Quick Navigation:',
                'location_setup': 'Location Setup',
                'weather_info': 'Weather Info',
                'search_advice': 'Search & AI',
                'monthly_calendar': 'Monthly Calendar',
                
                // Location section
                'location_placeholder': 'City or place name (e.g., Paris, Barcelona)',
                'location_focus_placeholder': 'City or place name',
                'use_my_location': 'Use my location',
                'temperature': 'Temperature:',
                'precipitation': 'Precipitation:',
                
                // Weather display
                'weather_placeholder': 'Weather information for your location will appear here.',
                'location': 'Location:',
                'latitude': 'Latitude:',
                'longitude': 'Longitude:',
                'loading_weather': 'Loading weather data...',
                'current_weather': 'Current weather:',
                'wind': 'Wind:',
                'forecast_16day': '16-day forecast:',
                
                // Search section
                'find_plants_tasks': 'Search & AI Garden Assistant',
                'generate_advice': 'Generate AI gardening advice prompt',
                'search_placeholder': 'Type to search for specific plants or garden tasks...',

                // Month selection
                'select_period': 'Select Growing Period',
                'april': 'April',
                'may': 'May',
                'early_june': 'Early June',
                
                // Plant categories
                'direct_sowing': 'Direct Sowing',
                'seedling_start': 'Starting Seedlings',
                'transplanting': 'Transplanting',
                'greenhouse': 'Greenhouse',
                'garden_tasks': 'Garden Tasks',
                
                // AI Prompt Modal
                'ai_assistant': 'AI Gardening Assistant',
                'prompt_description': 'This tool will generate a comprehensive prompt based on your location, weather, and garden information. You can use this prompt with any AI assistant to get personalized gardening advice.',
                'garden_notes': 'Your notes about your garden:',
                'include_prompt': 'Include in Prompt:',
                'selected_plants': 'Selected plants and tasks',
                'checked_items': '(Your checked items from the planting calendar)',
                'filter_weather': 'Filter for weather conditions',
                'suitable_forecast': '(Only include plants suitable for current forecast)',
                'generate_prompt': 'Generate Prompt',
                'copy_clipboard': 'Copy to Clipboard',
                'prompt_placeholder': 'Click "Generate Prompt" to create a customized gardening prompt based on your location, weather, and calendar data.',
                'send_prompt': 'Send Prompt Directly To:',
                'like_tool': 'Like this tool? Support its development!',
                
                // Footer
                'copyright': 'Spring Gardening and Planting Calendar ¬© 2025',
                'support': 'Support on Ko-fi'
            }
        };
        
        // Load additional languages dynamically
        async function loadLanguage(lang) {
            if (lang === 'en' || translations[lang]) {
                return translations[lang];
            }
            
            try {
                const response = await fetch(`gardening_calendar/translations/${lang}.json`);
                if (!response.ok) throw new Error(`Failed to load ${lang} translation`);
                const langData = await response.json();
                translations[lang] = langData;
                return langData;
            } catch (error) {
                console.error(`Error loading ${lang} translation:`, error);
                return null;
            }
        }
        
        // Current language (default to English)
        let currentLang = 'en';
        
        // Function to translate UI elements
        async function translateUI(lang) {
            // Load language if not already loaded
            const langData = await loadLanguage(lang);
            
            if (!langData) {
                console.error(`Translation for language ${lang} not found`);
                return;
            }
            
            currentLang = lang;
            const t = langData;
            
            // Save language preference
            localStorage.setItem('gardening_language', lang);
            
            // Update document title
            document.title = t.title;
            
            // Update text elements with data-i18n attributes
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (t[key]) {
                    el.textContent = t[key];
                }
            });
            
            // Update placeholders for inputs
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (t[key]) {
                    el.setAttribute('placeholder', t[key]);
                }
            });
            
            // Update aria-labels
            document.querySelectorAll('[data-i18n-aria]').forEach(el => {
                const key = el.getAttribute('data-i18n-aria');
                if (t[key]) {
                    el.setAttribute('aria-label', t[key]);
                }
            });
            
            // Update month buttons
            document.querySelectorAll('.month-btn').forEach(btn => {
                const month = btn.getAttribute('data-month');
                if (t[month]) {
                    btn.textContent = t[month];
                }
            });
            
            // Update input placeholders
            if (t.location_placeholder) {
                locationInput.setAttribute('placeholder', t.location_placeholder);
            }
            
            // Update search box placeholder
            const searchBox = document.getElementById('searchBox');
            if (searchBox && t.search_placeholder) {
                searchBox.setAttribute('placeholder', t.search_placeholder);
            }
            
            // Update calendar data for current language
            renderCalendar(activeMonth, searchBox?.value || '');
        }
        
        // Function to get translated string
        function getTranslation(key) {
            return translations[currentLang]?.[key] || key;
        }
        
        // Initialize language from localStorage or browser preference
        async function initLanguage() {
            let savedLang = localStorage.getItem('gardening_language');
            
            if (!savedLang) {
                // Try to detect from browser
                const browserLang = navigator.language.split('-')[0];
                savedLang = ['en', 'et'].includes(browserLang) ? browserLang : 'en';
            }
            
            await translateUI(savedLang);
        }
        
        // Data in JSON format
        const calendarData = {
            "april": {
                "direct_sowing": [
                    {"en": "carrot", "et": "porgand"},
                    {"en": "parsnip", "et": "pastinaak"},
                    {"en": "radish", "et": "redis"},
                    {"en": "turnip", "et": "naeris"},
                    {"en": "peas", "et": "hernes"},
                    {"en": "spinach", "et": "spinat"},
                    {"en": "arugula", "et": "rukola"},
                    {"en": "lettuce", "et": "salat"},
                    {"en": "dill", "et": "till"},
                    {"en": "parsley", "et": "petersell"}
                ],
                "seedling_start": [
                    {"en": "cabbage", "et": "kapsas"},
                    {"en": "cauliflower", "et": "lillkapsas"},
                    {"en": "broccoli", "et": "brokoli"},
                    {"en": "kale", "et": "lehtkapsas"},
                    {"en": "tomato", "et": "tomat"},
                    {"en": "pepper", "et": "paprika"},
                    {"en": "eggplant", "et": "bakla≈æaan"},
                    {"en": "pumpkin", "et": "k√µrvits"},
                    {"en": "zucchini", "et": "suvik√µrvits"},
                    {"en": "melon", "et": "melon"},
                    {"en": "basil", "et": "basiilik"},
                    {"en": "thyme", "et": "t√º√ºmian"},
                    {"en": "sage", "et": "salvei"}
                ],
                "greenhouse": [
                    {"en": "radish", "et": "redis"},
                    {"en": "spinach", "et": "spinat"},
                    {"en": "lettuce", "et": "salat"},
                    {"en": "dill", "et": "till"}
                ],
                "garden_tasks": [
                    {"en": "Pruning fruit trees and berry bushes (before bud break)", "et": "Viljapuude ja marjap√µ√µsaste l√µikamine (enne pungade puhkemist)"},
                    {"en": "Cleaning strawberry beds", "et": "Maasikapeenarde puhastamine"},
                    {"en": "Turning compost", "et": "Komposti segamine"},
                    {"en": "Cleaning and preparing greenhouse", "et": "Kasvuhoone puhastamine ja ettevalmistamine"},
                    {"en": "Loosening and fertilizing beds", "et": "Peenarde kobestamine ja v√§etamine"}
                ]
            },
            "may": {
                "direct_sowing": [
                    {"en": "carrot", "et": "porgand"},
                    {"en": "beetroot", "et": "peet"},
                    {"en": "radish", "et": "redis"},
                    {"en": "turnip", "et": "naeris"},
                    {"en": "parsnip", "et": "pastinaak"},
                    {"en": "dill", "et": "till"},
                    {"en": "parsley", "et": "petersell"},
                    {"en": "lettuce", "et": "salat"},
                    {"en": "arugula", "et": "rukola"},
                    {"en": "spinach (new sowing)", "et": "spinat (uus k√ºlv)"},
                    {"en": "chard", "et": "lehtpeet"},
                    {"en": "peas", "et": "hernes"},
                    {"en": "beans", "et": "oad"},
                    {"en": "potato", "et": "kartul"},
                    {"en": "onion (sets or seeds)", "et": "sibul (istikud v√µi seemned)"}
                ],
                "transplanting": [
                    {"en": "cabbage", "et": "kapsas"},
                    {"en": "cauliflower", "et": "lillkapsas"},
                    {"en": "broccoli", "et": "brokoli"},
                    {"en": "kale", "et": "lehtkapsas"},
                    {"en": "tomato (in greenhouse)", "et": "tomat (kasvuhoones)"},
                    {"en": "pepper (in greenhouse)", "et": "paprika (kasvuhoones)"},
                    {"en": "eggplant (in greenhouse)", "et": "bakla≈æaan (kasvuhoones)"},
                    {"en": "zucchini (late May)", "et": "suvik√µrvits (mai l√µpus)"},
                    {"en": "pumpkin (late May)", "et": "k√µrvits (mai l√µpus)"}
                ],
                "greenhouse": [
                    {"en": "tomato", "et": "tomat"},
                    {"en": "cucumber", "et": "kurk"},
                    {"en": "pepper", "et": "paprika"},
                    {"en": "eggplant", "et": "bakla≈æaan"},
                    {"en": "zucchini", "et": "suvik√µrvits"},
                    {"en": "basil", "et": "basiilik"}
                ],
                "garden_tasks": [
                    {"en": "Checking fruit tree flower buds (thinning if needed)", "et": "Viljapuude √µiepungade kontrollimine (vajadusel harvendamine)"},
                    {"en": "Planting containers and balcony plants", "et": "Pottide ja r√µdutaimede istutamine"},
                    {"en": "Adding mulch to beds", "et": "Mult≈°i lisamine peenardele"},
                    {"en": "Weed control", "et": "Umbrohut√µrje"},
                    {"en": "Adding green matter to compost", "et": "Rohelise materjali lisamine kompostile"}
                ]
            },
            "early_june": {
                "direct_sowing": [
                    {"en": "beans (late varieties)", "et": "oad (hilised sordid)"},
                    {"en": "zucchini (direct sowing)", "et": "suvik√µrvits (otse k√ºlvamine)"},
                    {"en": "cucumber (direct sowing)", "et": "kurk (otse k√ºlvamine)"}
                ],
                "transplanting": [
                    {"en": "zucchini", "et": "suvik√µrvits"},
                    {"en": "pumpkin", "et": "k√µrvits"},
                    {"en": "cucumber (if soil is warm)", "et": "kurk (kui muld on soe)"}
                ],
                "greenhouse": [
                    {"en": "Tomato maintenance and staking", "et": "Tomatite hooldus ja toestamine"},
                    {"en": "Fertilizing", "et": "V√§etamine"},
                    {"en": "Ventilation", "et": "√ïhutamine"},
                    {"en": "Removing side shoots", "et": "V√µsundite eemaldamine"},
                    {"en": "Succession planting (lettuce, radish, herbs)", "et": "J√§rkj√§rguline k√ºlvamine (salat, redis, maitsetaimed)"},
                    {"en": "Cucumber staking", "et": "Kurkide toestamine"}
                ],
                "garden_tasks": [
                    {"en": "Removing row covers", "et": "Reakattematerjali eemaldamine"},
                    {"en": "Monitoring watering schedule", "et": "Kastmisgraafiku j√§lgimine"},
                    {"en": "Weed control", "et": "Umbrohut√µrje"},
                    {"en": "Covering strawberries with bird netting", "et": "Maasikate katmine linnuv√µrguga"}
                ]
            }
        };

        // Category icons
        const categoryIcons = {
            "direct_sowing": "üå±",
            "seedling_start": "üåø",
            "transplanting": "üåø",
            "greenhouse": "üè°",
            "garden_tasks": "üß∞"
        };

        // Category names
        const categoryNames = {
            "direct_sowing": "Direct Sowing",
            "seedling_start": "Starting Seedlings",
            "transplanting": "Transplanting",
            "greenhouse": "Greenhouse",
            "garden_tasks": "Garden Tasks"
        };

        // DOM elements
        const calendarContent = document.getElementById('calendarContent');
        const monthButtons = document.querySelectorAll('.month-btn');
        const searchBox = document.getElementById('searchBox');

        // Active month (default April)
        let activeMonth = 'april';

        // Track last actions for retry
        let lastGeocodeQuery = null;
        let lastWeatherCoords = null;
        let lastWeatherAction = null; // 'geocode' or 'weather'

        // Store last fetched weather data for re-rendering
        let lastWeatherData = null;
        let lastWeatherLat = null;
        let lastWeatherLon = null;

        // --- K√∂ppen climate zone logic ---
        let koppenGrid = null;
        let userClimateZone = null;
        let userClimateZoneOverride = null;
        const climateZoneInfo = document.getElementById('climateZoneInfo');

        // Load the grid JSON
        fetch('gardening_calendar/data/koppen_grid_0.5deg.json')
            .then(r => r.json())
            .then(data => {
                koppenGrid = data;
                // If we already have a location, try to show zone
                const cached = localStorage.getItem('gardening_last_location');
                if (cached) {
                    try {
                        const loc = JSON.parse(cached);
                        if (loc.type === 'coords' && loc.lat && loc.lon) {
                            showClimateZone(loc.lat, loc.lon);
                        }
                    } catch (e) {}
                }
            });

        // Helper: round to nearest 0.25
        function round025(x) {
            // Ensure x is a number and round to either .25 or .75
            const num = typeof x === 'string' ? parseFloat(x) : x;
            const decimal = num % 1;
            const whole = Math.floor(num);
            let rounded;
            if (decimal < 0.375) {
                rounded = 0.25;
            } else if (decimal < 0.875) {
                rounded = 0.75;
            } else {
                rounded = 0.25;
                return (whole + 1 + rounded).toFixed(2);
            }
            return (whole + rounded).toFixed(2);
        }

        // Show climate zone info
        function showClimateZone(lat, lon) {
            if (!koppenGrid) {
                climateZoneInfo.innerHTML = '';
                return;
            }
            // Check for override
            const override = localStorage.getItem('gardening_climate_zone_override');
            let lookupKey = '';
            let foundZone = '';
            if (override) {
                userClimateZoneOverride = override;
                userClimateZone = override;
                lookupKey = '(override)';
                foundZone = override;
            } else {
                const latNum = typeof lat === 'string' ? parseFloat(lat) : lat;
                const lonNum = typeof lon === 'string' ? parseFloat(lon) : lon;
                const key = `${round025(latNum)} ${round025(lonNum)}`;
                // Try exact match first
                if (koppenGrid[key]) {
                    userClimateZone = koppenGrid[key];
                    lookupKey = key;
                    foundZone = userClimateZone;
                } else {
                    // Find nearest neighbor
                    const roundedLat = round025(latNum);
                    const roundedLon = round025(lonNum);
                    let minDistance = Infinity;
                    let nearestZone = null;
                    let nearestKey = null;
                    
                    // Search in nearby coordinates (¬±1 degree should be enough)
                    for (const gridKey in koppenGrid) {
                        const [gridLat, gridLon] = gridKey.split(' ').map(Number);
                        if (Math.abs(gridLat - roundedLat) <= 1 && Math.abs(gridLon - roundedLon) <= 1) {
                            const distance = Math.sqrt(
                                Math.pow(gridLat - roundedLat, 2) + 
                                Math.pow(gridLon - roundedLon, 2)
                            );
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestZone = koppenGrid[gridKey];
                                nearestKey = gridKey;
                            }
                        }
                    }
                    
                    if (nearestZone) {
                        userClimateZone = nearestZone;
                        lookupKey = `${key} (nearest: ${nearestKey}, dist: ${minDistance.toFixed(2)}¬∞)`;
                        foundZone = nearestZone;
                    } else {
                        userClimateZone = 'Unknown';
                        lookupKey = key;
                        foundZone = 'Unknown';
                    }
                }
            }
            renderClimateZoneUI(lookupKey, foundZone);
        }

        // Render the climate zone UI (with debug info)
        function renderClimateZoneUI(lookupKey = '', foundZone = '') {
            let html = '';
            if (userClimateZone) {
                html += `<div style="margin-top: 15px; padding: 10px 15px; background: var(--white); border-radius: 8px; box-shadow: 0 1px 3px var(--shadow);">`;
                html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">`;
                html += `<strong>Climate zone:</strong> <span id="climateZoneCode" style="background: var(--light-bg); padding: 2px 8px; border-radius: 4px; font-family: monospace;">${userClimateZone}</span>`;
                html += `<a href="https://en.wikipedia.org/wiki/K%C3%B6ppen_climate_classification" target="_blank" style="color: var(--primary-color); text-decoration: none; font-size: 0.95em;">(What is this?)</a>`;
                html += `</div>`;
                html += `<div style="display: flex; align-items: center; gap: 10px;">`;
                html += `<label for="climateZoneOverride" style="font-size: 0.95em;">Override zone:</label>`;
                html += `<input id="climateZoneOverride" type="text" style="padding: 4px 8px; border: 1px solid var(--secondary-color); border-radius: 4px; width: 60px;" value="${userClimateZoneOverride || ''}" placeholder="e.g. Dfb">`;
                html += `<button id="setClimateZoneOverrideBtn" style="padding: 4px 10px; background: var(--secondary-color); color: white; border: none; border-radius: 4px; font-size: 0.95em; cursor: pointer;">Set</button>`;
                html += `<button id="clearClimateZoneOverrideBtn" style="padding: 4px 10px; background: var(--accent-color); color: white; border: none; border-radius: 4px; font-size: 0.95em; cursor: pointer;">Clear</button>`;
                html += `</div></div>`;
            }
            climateZoneInfo.innerHTML = html;

            // Add listeners
            const setBtn = document.getElementById('setClimateZoneOverrideBtn');
            const clearBtn = document.getElementById('clearClimateZoneOverrideBtn');
            if (setBtn) {
                setBtn.addEventListener('click', function() {
                    const val = document.getElementById('climateZoneOverride').value.trim();
                    if (val) {
                        localStorage.setItem('gardening_climate_zone_override', val);
                        userClimateZoneOverride = val;
                        userClimateZone = val;
                        renderClimateZoneUI();
                    }
                });
            }
            if (clearBtn) {
                clearBtn.addEventListener('click', function() {
                    localStorage.removeItem('gardening_climate_zone_override');
                    userClimateZoneOverride = null;
                    // Recompute from location
                    const cached = localStorage.getItem('gardening_last_location');
                    if (cached) {
                        try {
                            const loc = JSON.parse(cached);
                            if (loc.type === 'coords' && loc.lat && loc.lon) {
                                const latNum = typeof loc.lat === 'string' ? parseFloat(loc.lat) : loc.lat;
                                const lonNum = typeof loc.lon === 'string' ? parseFloat(loc.lon) : loc.lon;
                                showClimateZone(latNum, lonNum);
                                return;
                            }
                        } catch (e) {}
                    }
                    renderClimateZoneUI();
                });
            }
        }

        // Helper: Convert temperature and precipitation
        function convertTemp(val, unit) {
            if (unit === 'F') return Math.round(val * 9/5 + 32);
            return Math.round(val);
        }
        function convertPrecip(val, unit) {
            if (unit === 'in') return (val / 25.4).toFixed(2);
            return val;
        }
        function getTempUnitSymbol() {
            return tempUnitSelect.value === 'F' ? '¬∞F' : '¬∞C';
        }
        function getPrecipUnitSymbol() {
            return precipUnitSelect.value === 'in' ? 'in' : 'mm';
        }

        // Function to render calendar content
        function renderCalendar(month, searchTerm = '') {
            // Clear content
            calendarContent.innerHTML = '';
            
            // Check if month has data
            if (!calendarData[month]) {
                calendarContent.innerHTML = `<div class="no-results">${getTranslation('no_data_available')}</div>`;
                return;
            }
            
            // Show categories
            const categories = Object.keys(calendarData[month]);
            
            // Filter for search
            let hasResults = false;
            let delay = 0;
            
            categories.forEach(category => {
                const items = calendarData[month][category];
                let filteredItems = items;
                
                // Apply filter if search term exists
                if (searchTerm) {
                    filteredItems = items.filter(item => {
                        const itemText = item[currentLang] || item.en;
                        return itemText.toLowerCase().includes(searchTerm.toLowerCase());
                    });
                }
                
                // Don't show category if no results after filtering
                if (filteredItems.length === 0 && searchTerm) {
                    return;
                }
                
                hasResults = true;
                
                // Create category card
                const categoryCard = document.createElement('div');
                const categoryClass = category === 'garden_tasks' ? 'category-card garden-tasks-card' : 'category-card';
                categoryCard.className = `${categoryClass} fade-in`;
                categoryCard.style.animationDelay = `${delay}ms`;
                delay += 100;
                
                // Icon and title
                const isTaskCategory = category === 'garden_tasks';
                const categoryDisplayName = translations[currentLang][category] || categoryNames[category] || category;
                
                categoryCard.innerHTML = `
                    <div class="category-header">
                        <div class="category-icon">${categoryIcons[category] || 'üåø'}</div>
                        <h2 class="category-title">${categoryDisplayName}</h2>
                    </div>
                    <div class="select-all-container">
                        <label class="select-all-label">
                            <input type="checkbox" class="select-all-checkbox" data-category="${category}">
                            <span>Select All ${isTaskCategory ? 'Tasks' : 'Plants'}</span>
                        </label>
                    </div>
                    <ul class="plant-list">
                        ${filteredItems.map(item => {
                            const itemText = item[currentLang] || item.en;
                            const itemId = JSON.stringify(item); // Store the full item object
                            const displayText = searchTerm ? highlightText(itemText, searchTerm) : itemText;
                            
                            return `
                                <li class="${isTaskCategory ? 'task-item' : 'plant-item'}" data-item-id="${encodeURIComponent(itemId)}">
                                    <label class="item-label">
                                        <input type="checkbox" class="item-checkbox" 
                                            ${isItemSelected(month, category, item) ? 'checked' : ''}>
                                        <span class="item-text">${displayText}</span>
                                    </label>
                                </li>
                            `;
                        }).join('')}
                    </ul>
                `;

                // Add event listeners for checkboxes
                categoryCard.querySelectorAll('.item-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const itemJson = decodeURIComponent(e.target.closest('li').dataset.itemId);
                        const item = JSON.parse(itemJson);
                        toggleItemSelection(month, category, item, e.target.checked);
                    });
                });
                
                calendarContent.appendChild(categoryCard);
            });
            
            // If no results found
            if (!hasResults) {
                calendarContent.innerHTML = `<div class="no-results">${translations[currentLang].no_results || 'No results found for your search.'}</div>`;
            }

            // Add event listeners for "Select All" checkboxes
            const selectAllCheckboxes = document.querySelectorAll('.select-all-checkbox');
            selectAllCheckboxes.forEach(checkbox => {
                const category = checkbox.dataset.category;
                
                // Initial state: check if all items are selected
                const categoryItems = calendarData[month][category] || [];
                if (categoryItems.length > 0) {
                    // Check if ALL items in this category are selected
                    let allSelected = true;
                    for (let i = 0; i < categoryItems.length; i++) {
                        if (!isItemSelected(month, category, categoryItems[i])) {
                            allSelected = false;
                            break;
                        }
                    }
                    checkbox.checked = allSelected;
                    console.log(`Initializing "Select All" for ${category}: ${allSelected}`);
                }
                
                // Add change event
                checkbox.addEventListener('change', (e) => {
                    const isChecked = e.target.checked;
                    const categoryCard = e.target.closest('.category-card');
                    const checkboxes = categoryCard.querySelectorAll('.item-checkbox');
                    
                    // Update all checkboxes in this category
                    checkboxes.forEach(itemCheckbox => {
                        if (itemCheckbox.checked !== isChecked) {
                            itemCheckbox.checked = isChecked;
                            
                            // Get and update the item
                            const itemLi = itemCheckbox.closest('li');
                            const itemJson = decodeURIComponent(itemLi.dataset.itemId);
                            const item = JSON.parse(itemJson);
                            toggleItemSelection(month, category, item, isChecked);
                        }
                    });
                });
            });
        }

        // Search function
        function searchCalendar() {
            const searchTerm = searchBox.value.trim();
            renderCalendar(activeMonth, searchTerm);
        }

        // Text highlighting function
        function highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            
            const regex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        // Escape special characters in regular expression
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Listen for month button clicks
        monthButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons
                monthButtons.forEach(btn => btn.classList.remove('active'));
                
                // Add active class to clicked button
                button.classList.add('active');
                
                // Update active month
                activeMonth = button.dataset.month;
                
                // Show calendar
                searchBox.value = ''; // Reset search
                renderCalendar(activeMonth);
            });
        });

        // Listen for search input
        searchBox.addEventListener('input', searchCalendar);

        // Initial calendar display
        renderCalendar(activeMonth);

        // Weather/location handling
        const locationInput = document.getElementById('locationInput');
        const useMyLocationBtn = document.getElementById('useMyLocationBtn');
        const weatherPlaceholder = document.getElementById('weatherPlaceholder');

        // Helper: Display error with optional retry
        function displayLocationError(msg, retryType = null) {
            let retryBtn = '';
            if (retryType === 'geocode') {
                retryBtn = '<button id="retryGeocodeBtn" style="margin-left:12px;">Retry</button>';
            } else if (retryType === 'weather') {
                retryBtn = '<button id="retryWeatherBtn" style="margin-left:12px;">Retry</button>';
            }
            weatherPlaceholder.innerHTML = `<div role="alert" style="color: #b71c1c;">${msg}${retryBtn}</div>`;
            if (retryType === 'geocode') {
                const btn = document.getElementById('retryGeocodeBtn');
                if (btn) btn.onclick = () => {
                    if (lastGeocodeQuery) geocodeLocation(lastGeocodeQuery, true);
                };
            } else if (retryType === 'weather') {
                const btn = document.getElementById('retryWeatherBtn');
                if (btn) btn.onclick = () => {
                    if (lastWeatherCoords) fetchWeatherData(lastWeatherCoords.lat, lastWeatherCoords.lon, true);
                };
            }
        }

        // Helper: Display location and coordinates, then fetch and display weather
        function displayLocationInfo(name, lat, lon, admin1, admin2, country) {
            let locationParts = [];
            if (name) locationParts.push(name);
            if (admin2) locationParts.push(admin2);
            if (admin1) locationParts.push(admin1);
            if (country) locationParts.push(country);
            const locationString = locationParts.join(', ');
            weatherPlaceholder.innerHTML =
                `<div class="weather-location-info"><strong>Location:</strong> ${locationString}<br><br>` +
                `<span style="font-size:0.97em;color:#666;">Latitude: ${lat}, Longitude: ${lon}</span></div>` +
                `<div id="weatherDataSection">Loading weather data...</div>`;
            lastWeatherCoords = { lat, lon };
            lastWeatherAction = 'weather';
            fetchWeatherData(lat, lon);
            showClimateZone(lat, lon);
        }

        // Weather code to icon, text, and color (Open-Meteo codes)
        function weatherCodeToIconTextColor(code) {
            // Weather type to color mapping
            const typeColors = {
                sun:   { bg: '#fffde7', color: '#fbc02d' },
                cloud: { bg: '#eceff1', color: '#607d8b' },
                rain:  { bg: '#e3f2fd', color: '#1976d2' },
                snow:  { bg: '#f3e5f5', color: '#7e57c2' },
                storm: { bg: '#ffe0b2', color: '#e65100' },
                fog:   { bg: '#f5f5f5', color: '#757575' },
                unknown: { bg: '#eeeeee', color: '#888' }
            };
            // Map weather code to icon, text, and type
            const map = {
                0:  {icon: '‚òÄÔ∏è', text: 'Clear sky', type: 'sun'},
                1:  {icon: 'üå§Ô∏è', text: 'Mainly clear', type: 'sun'},
                2:  {icon: '‚õÖ', text: 'Partly cloudy', type: 'cloud'},
                3:  {icon: '‚òÅÔ∏è', text: 'Overcast', type: 'cloud'},
                45: {icon: 'üå´Ô∏è', text: 'Fog', type: 'fog'},
                48: {icon: 'üå´Ô∏è', text: 'Rime fog', type: 'fog'},
                51: {icon: 'üå¶Ô∏è', text: 'Light drizzle', type: 'rain'},
                53: {icon: 'üå¶Ô∏è', text: 'Drizzle', type: 'rain'},
                55: {icon: 'üå¶Ô∏è', text: 'Dense drizzle', type: 'rain'},
                56: {icon: 'üåßÔ∏è', text: 'Freezing light drizzle', type: 'rain'},
                57: {icon: 'üåßÔ∏è', text: 'Freezing drizzle', type: 'rain'},
                61: {icon: 'üå¶Ô∏è', text: 'Slight rain', type: 'rain'},
                63: {icon: 'üåßÔ∏è', text: 'Rain', type: 'rain'},
                65: {icon: 'üåßÔ∏è', text: 'Heavy rain', type: 'rain'},
                66: {icon: 'üåßÔ∏è', text: 'Freezing light rain', type: 'rain'},
                67: {icon: 'üåßÔ∏è', text: 'Freezing rain', type: 'rain'},
                71: {icon: 'üå®Ô∏è', text: 'Slight snow fall', type: 'snow'},
                73: {icon: 'üå®Ô∏è', text: 'Snow fall', type: 'snow'},
                75: {icon: '‚ùÑÔ∏è', text: 'Heavy snow fall', type: 'snow'},
                77: {icon: '‚ùÑÔ∏è', text: 'Snow grains', type: 'snow'},
                80: {icon: 'üå¶Ô∏è', text: 'Slight rain showers', type: 'rain'},
                81: {icon: 'üåßÔ∏è', text: 'Rain showers', type: 'rain'},
                82: {icon: 'üåßÔ∏è', text: 'Violent rain showers', type: 'rain'},
                85: {icon: 'üå®Ô∏è', text: 'Slight snow showers', type: 'snow'},
                86: {icon: 'üå®Ô∏è', text: 'Snow showers', type: 'snow'},
                95: {icon: '‚õàÔ∏è', text: 'Thunderstorm', type: 'storm'},
                96: {icon: '‚õàÔ∏è', text: 'Thunderstorm w/ hail', type: 'storm'},
                99: {icon: '‚õàÔ∏è', text: 'Thunderstorm w/ heavy hail', type: 'storm'}
            };
            const entry = map[code] || {icon: '‚ùì', text: 'Unknown', type: 'unknown'};
            const color = typeColors[entry.type] || typeColors.unknown;
            return { ...entry, ...color };
        }

        // Fetch weather data from Open-Meteo
        async function fetchWeatherData(lat, lon, isRetry = false) {
            lastWeatherCoords = { lat, lon };
            lastWeatherAction = 'weather';
            lastWeatherLat = lat;
            lastWeatherLon = lon;
            const weatherSection = document.getElementById('weatherDataSection');
            if (!weatherSection) return;
            weatherSection.textContent = 'Loading weather data...';
            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,weathercode&hourly=temperature_2m,precipitation,windspeed_10m&forecast_days=16&timezone=auto`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Weather service error');
                const data = await response.json();
                lastWeatherData = data;
                if (!data.current_weather || !data.daily || !data.hourly) {
                    weatherSection.innerHTML = '<div role="alert" style="color: #b71c1c;">Weather data not available for this location.</div>';
                    return;
                }
                renderWeatherData(data);
            } catch (e) {
                if (weatherSection) {
                    weatherSection.innerHTML = '<div role="alert" style="color: #b71c1c;">Could not fetch weather data. <button id="retryWeatherBtn" style="margin-left:12px;">Retry</button></div>';
                    const btn = document.getElementById('retryWeatherBtn');
                    if (btn) btn.onclick = () => {
                        if (lastWeatherCoords) fetchWeatherData(lastWeatherCoords.lat, lastWeatherCoords.lon, true);
                    };
                }
            }
        }

        // Render weather data in selected units
        function renderWeatherData(data) {
            const weatherSection = document.getElementById('weatherDataSection');
            if (!weatherSection) return;
            const tempUnit = tempUnitSelect.value;
            const precipUnit = precipUnitSelect.value;
            // Display current weather
            const currentIconTextColor = weatherCodeToIconTextColor(data.current_weather.weathercode);
            let html = `<div class="weather-current"><strong>Current weather:</strong> <span style="display:inline-block;background:${currentIconTextColor.bg};border-radius:50%;padding:6px 10px;font-size:1.4em;color:${currentIconTextColor.color};margin-right:6px;">${currentIconTextColor.icon}</span> ${currentIconTextColor.text}, ${convertTemp(data.current_weather.temperature, tempUnit)}${getTempUnitSymbol()}, Wind: ${data.current_weather.windspeed} km/h</div>`;
            // Prepare hourly data grouped by day
            const hourlyByDay = groupHourlyByDay(data.hourly, data.daily.time);
            const hourlyPrecipByDay = groupHourlyByDay({ time: data.hourly.time, temperature_2m: data.hourly.precipitation }, data.daily.time);
            const hourlyWindByDay = groupHourlyByDay({ time: data.hourly.time, temperature_2m: data.hourly.windspeed_10m }, data.daily.time);
            // Display forecast table
            html += `<div style="margin-top:10px;"><strong>16-day forecast:</strong></div>`;
            html += `<table class="weather-forecast-table"><caption class='visually-hidden'>16-day weather forecast for selected location</caption><thead><tr><th scope='col'>Date</th><th scope='col'>Night Min</th><th scope='col'>Night Max</th><th scope='col'>Day Min</th><th scope='col'>Day Max</th><th scope='col'>Precip.</th><th scope='col'>Weather</th><th scope='col'>Temp Trend</th></tr></thead><tbody>`;
            for (let i = 0; i < data.daily.time.length; i++) {
                const { nightMin, nightMax, dayMin, dayMax } = calcNightDayMinMax(hourlyByDay[i]);
                const weatherIconTextColor = weatherCodeToIconTextColor(data.daily.weathercode[i]);
                
                // Color-code the temperature cells
                function getTempHtml(tempValue) {
                    if (tempValue === null) return '-';
                    const temp = convertTemp(tempValue, tempUnit);
                    const tempColor = getTemperatureColor(temp, tempUnit);
                    
                    // Calculate contrasting text color (black or white) based on background color
                    // Convert hex color to RGB to calculate luminance
                    const hexToRgb = (hex) => {
                        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        const fullHex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHex);
                        return result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : {r: 0, g: 0, b: 0};
                    };
                    
                    // Calculate relative luminance for accessibility contrast
                    const rgb = hexToRgb(tempColor);
                    
                    // Use the original color but with reduced opacity for a softer look
                    const bgColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.25)`;
                    const textColor = '#333333';
                    const borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.5)`;
                    
                    return `<span style="display:inline-block;background-color:${bgColor};color:${textColor};padding:2px 6px;border-radius:4px;font-weight:500;border:1px solid ${borderColor};">${temp}${getTempUnitSymbol()}</span>`;
                }
                
                html += `<tr>
                    <td>${data.daily.time[i]}</td>
                    <td>${getTempHtml(nightMin)}</td>
                    <td>${getTempHtml(nightMax)}</td>
                    <td>${getTempHtml(dayMin)}</td>
                    <td>${getTempHtml(dayMax)}</td>
                    <td>${convertPrecip(data.daily.precipitation_sum[i], precipUnit)} ${getPrecipUnitSymbol()}</td>
                    <td><span style='display:inline-block;background:${weatherIconTextColor.bg};border-radius:50%;padding:7px 12px;font-size:1.5em;color:${weatherIconTextColor.color};margin-bottom:2px;'>${weatherIconTextColor.icon}</span><br><span style='color:${weatherIconTextColor.color};font-size:0.93em;'>${weatherIconTextColor.text}</span></td>
                    <td>${renderSparkline(hourlyByDay[i], i, tempUnit)}</td>
                </tr>`;
            }
            html += `</tbody></table>`;
            weatherSection.innerHTML = html;
            // Add event listeners for sparklines
            addSparklineListeners(hourlyByDay, data.daily.time, hourlyPrecipByDay, hourlyWindByDay, tempUnit, precipUnit);
        }

        // Calculate night and day min/max for a day's hourly temps
        function calcNightDayMinMax(temps) {
            if (!temps || temps.length !== 24) return { nightMin: null, nightMax: null, dayMin: null, dayMax: null };
            // Night: 21:00‚Äì23:00 (21,22,23) and 00:00‚Äì05:00 (0,1,2,3,4,5)
            const nightHours = [21,22,23,0,1,2,3,4,5];
            const dayHours = [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];
            const nightTemps = nightHours.map(h => temps[h]).filter(t => t !== undefined);
            const dayTemps = dayHours.map(h => temps[h]).filter(t => t !== undefined);
            return {
                nightMin: nightTemps.length ? Math.round(Math.min(...nightTemps)) : null,
                nightMax: nightTemps.length ? Math.round(Math.max(...nightTemps)) : null,
                dayMin: dayTemps.length ? Math.round(Math.min(...dayTemps)) : null,
                dayMax: dayTemps.length ? Math.round(Math.max(...dayTemps)) : null
            };
        }

        // Group hourly temperature data by day
        function groupHourlyByDay(hourly, dailyDates) {
            const result = [];
            const hours = hourly.time;
            const temps = hourly.temperature_2m;
            let dayIndex = 0;
            let currentDay = dailyDates[dayIndex];
            let dayTemps = [];
            for (let i = 0; i < hours.length; i++) {
                if (hours[i].startsWith(currentDay)) {
                    dayTemps.push(temps[i]);
                } else {
                    result.push(dayTemps);
                    dayTemps = [];
                    dayIndex++;
                    currentDay = dailyDates[dayIndex];
                    if (!currentDay) break;
                    if (hours[i].startsWith(currentDay)) {
                        dayTemps.push(temps[i]);
                    }
                }
            }
            if (dayTemps.length) result.push(dayTemps);
            return result;
        }

        // Shared temperature color mapping function
        function getTemperatureColor(temp, tempUnit) {
            // Define more granular temperature steps
            const temperatureSteps = tempUnit === 'F' ? [
                { threshold: 14, color: '#0d47a1' },   // Very cold (deep blue)
                { threshold: 23, color: '#1565c0' },   // Freezing (deep blue-mid blue)
                { threshold: 32, color: '#1976d2' },   // Freezing point (mid blue)
                { threshold: 41, color: '#1e88e5' },   // Cold (blue)
                { threshold: 50, color: '#42a5f5' },   // Cool (light blue)
                { threshold: 59, color: '#64b5f6' },   // Cool-mild (pale blue)
                { threshold: 64, color: '#81c784' },   // Mild (light green)
                { threshold: 68, color: '#4caf50' },   // Mild-comfortable (medium green)
                { threshold: 73, color: '#7cb342' },   // Comfortable (green-yellow)
                { threshold: 77, color: '#9e9d24' },   // Warm (yellow-green)
                { threshold: 82, color: '#ffb74d' },   // Warm-hot (light orange)
                { threshold: 86, color: '#ff9800' },   // Hot (orange)
                { threshold: 91, color: '#f57c00' },   // Very hot (dark orange)
                { threshold: 95, color: '#e64a19' },   // Extremely hot (orange-red)
                { threshold: 100, color: '#d32f2f' },  // Dangerous heat (red)
                { threshold: Infinity, color: '#b71c1c' } // Extreme heat (deep red)
            ] : [
                { threshold: -20, color: '#0d47a1' },  // Extreme cold (deep blue)
                { threshold: -15, color: '#1565c0' },  // Very cold (deep blue-mid blue)
                { threshold: -10, color: '#1976d2' },  // Very cold (mid blue)
                { threshold: -5, color: '#1e88e5' },   // Cold (blue)
                { threshold: 0, color: '#42a5f5' },    // Freezing (light blue)
                { threshold: 5, color: '#64b5f6' },    // Cool (pale blue)
                { threshold: 10, color: '#81c784' },   // Cool-mild (light green)
                { threshold: 15, color: '#4caf50' },   // Mild (medium green)
                { threshold: 20, color: '#7cb342' },   // Comfortable (green-yellow)
                { threshold: 23, color: '#9e9d24' },   // Warm (yellow-green)
                { threshold: 26, color: '#ffb74d' },   // Warm-hot (light orange)
                { threshold: 30, color: '#ff9800' },   // Hot (orange)
                { threshold: 33, color: '#f57c00' },   // Very hot (dark orange)
                { threshold: 36, color: '#e64a19' },   // Extremely hot (orange-red)
                { threshold: 40, color: '#d32f2f' },   // Dangerous heat (red)
                { threshold: Infinity, color: '#b71c1c' } // Extreme heat (deep red)
            ];
            
            // Find the appropriate color based on temperature
            for (const step of temperatureSteps) {
                if (temp <= step.threshold) {
                    return step.color;
                }
            }
            return '#b71c1c'; // Fallback to deepest red
        }

        // Render a mini SVG sparkline for a day's temperatures
        function renderSparkline(temps, dayIndex, tempUnit) {
            if (!temps || temps.length === 0) return '';
            const w = 60, h = 40;
            // Convert all temps for sparkline
            const convertedTemps = temps.map(t => convertTemp(t, tempUnit));
            
            // Use absolute temperature ranges for consistent coloring
            // -10¬∞C (14¬∞F) to 40¬∞C (104¬∞F) is a reasonable range for most weather
            const absMinTemp = tempUnit === 'F' ? 14 : -10;
            const absMaxTemp = tempUnit === 'F' ? 104 : 40;
            
            // Use local min/max for the height calculations only
            const min = Math.min(...convertedTemps);
            const max = Math.max(...convertedTemps);
            const range = max - min || 1;
            
            // Create a smooth curve using cubic bezier curves
            let path = '';
            const allPoints = [];
            let pathSegments = [];
            
            convertedTemps.forEach((t, i) => {
                const x = (i / (convertedTemps.length - 1)) * (w - 2) + 1;
                const y = h - 2 - ((t - min) / range) * (h - 4);
                allPoints.push({ x, y, temp: t });
            });
            
            // Build smooth path using cubic bezier curves
            if (allPoints.length > 0) {
                path = `M ${allPoints[0].x.toFixed(1)},${allPoints[0].y.toFixed(1)}`;
                
                for (let i = 0; i < allPoints.length - 1; i++) {
                    const current = allPoints[i];
                    const next = allPoints[i + 1];
                    
                    // Calculate control points for smooth curve
                    const cpx1 = current.x + (next.x - current.x) / 3;
                    const cpy1 = current.y;
                    const cpx2 = current.x + 2 * (next.x - current.x) / 3;
                    const cpy2 = next.y;
                    
                    const segment = `C${cpx1.toFixed(1)},${cpy1.toFixed(1)} ${cpx2.toFixed(1)},${cpy2.toFixed(1)} ${next.x.toFixed(1)},${next.y.toFixed(1)}`;
                    path += ` ${segment}`;
                    
                    // Store segment with average temperature for coloring
                    const avgTemp = (current.temp + next.temp) / 2;
                    pathSegments.push({
                        segment: segment,
                        temp: avgTemp,
                        startX: current.x,
                        endX: next.x
                    });
                }
            }
            
            // Reference lines for 0 and 20 (in selected unit)
            const y0 = h - 2 - ((convertTemp(0, tempUnit) - min) / range) * (h - 4);
            const y20 = h - 2 - ((convertTemp(20, tempUnit) - min) / range) * (h - 4);
            
            // Create multiple path elements with different colors based on temperature
            let coloredPaths = '';
            
            if (allPoints.length > 0) {
                // Don't start with an incomplete path
                
                pathSegments.forEach((segment, i) => {
                    const color = getTemperatureColor(segment.temp, tempUnit);
                    coloredPaths += `<path d="M ${segment.startX.toFixed(1)},${allPoints[i].y.toFixed(1)} ${segment.segment}" 
                        fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />`;
                });
            }
            
            return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="vertical-align:middle;cursor:pointer;" data-day-index="${dayIndex}">
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y0.toFixed(1)} ${w},${y0.toFixed(1)}" opacity="0.5" />
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y20.toFixed(1)} ${w},${y20.toFixed(1)}" opacity="0.5" />
                ${coloredPaths}
            </svg>`;
        }

        // Render a larger SVG chart for modal
        function renderLargeTempChart(temps, tempUnit) {
            if (!temps || temps.length === 0) return '';
            const w = 340, h = 100;
            // Convert all temps for chart
            const convertedTemps = temps.map(t => convertTemp(t, tempUnit));
            
            // Use absolute temperature ranges for consistent coloring
            // -10¬∞C (14¬∞F) to 40¬∞C (104¬∞F) is a reasonable range for most weather
            const absMinTemp = tempUnit === 'F' ? 14 : -10;
            const absMaxTemp = tempUnit === 'F' ? 104 : 40;
            
            // Use local min/max for the height calculations only
            const min = Math.min(...convertedTemps);
            const max = Math.max(...convertedTemps);
            const range = max - min || 1;
            
            // Create a smooth curve using cubic bezier curves
            let path = '';
            const allPoints = [];
            let pathSegments = [];
            
            convertedTemps.forEach((t, i) => {
                const x = (i / (convertedTemps.length - 1)) * (w - 2) + 1;
                const y = h - 20 - ((t - min) / range) * (h - 40);
                allPoints.push({ x, y, temp: t });
            });
            
            // Build smooth path using cubic bezier curves
            if (allPoints.length > 0) {
                path = `M ${allPoints[0].x.toFixed(1)},${allPoints[0].y.toFixed(1)}`;
                
                for (let i = 0; i < allPoints.length - 1; i++) {
                    const current = allPoints[i];
                    const next = allPoints[i + 1];
                    
                    // Calculate control points for smooth curve
                    const cpx1 = current.x + (next.x - current.x) / 3;
                    const cpy1 = current.y;
                    const cpx2 = current.x + 2 * (next.x - current.x) / 3;
                    const cpy2 = next.y;
                    
                    const segment = `C${cpx1.toFixed(1)},${cpy1.toFixed(1)} ${cpx2.toFixed(1)},${cpy2.toFixed(1)} ${next.x.toFixed(1)},${next.y.toFixed(1)}`;
                    path += ` ${segment}`;
                    
                    // Store segment with average temperature for coloring
                    const avgTemp = (current.temp + next.temp) / 2;
                    pathSegments.push({
                        segment: segment,
                        temp: avgTemp,
                        startX: current.x,
                        endX: next.x
                    });
                }
            }
            
            // Reference lines for 0 and 20 (in selected unit)
            const y0 = h - 20 - ((convertTemp(0, tempUnit) - min) / range) * (h - 40);
            const y20 = h - 20 - ((convertTemp(20, tempUnit) - min) / range) * (h - 40);
            const minLabel = min + getTempUnitSymbol();
            const maxLabel = max + getTempUnitSymbol();
            
            // Create multiple path elements with different colors based on temperature
            let coloredPaths = '';
            
            if (allPoints.length > 0) {
                // Don't start with an incomplete path
                
                pathSegments.forEach((segment, i) => {
                    const color = getTemperatureColor(segment.temp, tempUnit);
                    coloredPaths += `<path d="M ${segment.startX.toFixed(1)},${allPoints[i].y.toFixed(1)} ${segment.segment}" 
                        fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />`;
                });
            }
            
            return `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y0.toFixed(1)} ${w},${y0.toFixed(1)}" opacity="0.5" />
                <polyline fill="none" stroke="#bbb" stroke-width="1" points="0,${y20.toFixed(1)} ${w},${y20.toFixed(1)}" opacity="0.5" />
                ${coloredPaths}
                <text x="2" y="${h - 22}" font-size="11" fill="#888">${minLabel}</text>
                <text x="2" y="18" font-size="11" fill="#888">${maxLabel}</text>
            </svg>`;
        }

        // Show modal with detailed chart and hourly temps
        function showWeatherModal(dayIndex, date, temps, precips, winds) {
            // Track weather detail view in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'view_weather_details', {
                    'date': date,
                    'day_index': dayIndex
                });
            }
            
            // Remove any existing modal
            const oldModal = document.getElementById('weatherModalOverlay');
            if (oldModal) oldModal.remove();
            // Build hourly table
            const tempUnit = tempUnitSelect.value;
            const precipUnit = precipUnitSelect.value;
            let hourlyTable = '<table class="weather-modal-hourly-table"><thead><tr><th>Hour</th><th>Temp (' + getTempUnitSymbol() + ')</th><th>Precip. (' + getPrecipUnitSymbol() + ')</th><th>Wind (km/h)</th></tr></thead><tbody>';
            for (let h = 0; h < temps.length; h++) {
                // Color-code the temperature cell
                const temp = convertTemp(temps[h], tempUnit);
                const tempColor = getTemperatureColor(temp, tempUnit);
                
                // Calculate contrasting text color (black or white) based on background color
                const hexToRgb = (hex) => {
                    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                    const fullHex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHex);
                    return result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : {r: 0, g: 0, b: 0};
                };
                
                // Calculate relative luminance for accessibility contrast
                const rgb = hexToRgb(tempColor);
                
                // Use the original color but with reduced opacity for a softer look
                const bgColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.25)`;
                const textColor = '#333333';
                const borderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.5)`;
                
                const tempHtml = `<span style="display:inline-block;background-color:${bgColor};color:${textColor};padding:2px 6px;border-radius:4px;font-weight:500;width:100%;border:1px solid ${borderColor};">${temp}${getTempUnitSymbol()}</span>`;
                
                hourlyTable += `<tr>
                    <td>${h}:00</td>
                    <td>${tempHtml}</td>
                    <td>${precips && precips[h] !== undefined ? convertPrecip(precips[h], precipUnit) : '-'}</td>
                    <td>${winds && winds[h] !== undefined ? Math.round(winds[h]) : '-'}</td>
                </tr>`;
            }
            hourlyTable += '</tbody></table>';
            // Modal HTML
            const modalHtml = `
                <div class="weather-modal-overlay" id="weatherModalOverlay" tabindex="-1">
                    <div class="weather-modal" role="dialog" aria-modal="true" aria-labelledby="weatherModalTitle">
                        <button class="weather-modal-close" id="weatherModalCloseBtn" aria-label="Close weather details">&times;</button>
                        <div class="weather-modal-title" id="weatherModalTitle">Hourly Weather for ${date}</div>
                        <div class="weather-modal-chart">${renderLargeTempChart(temps, tempUnit)}</div>
                        ${hourlyTable}
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            // Focus management
            const closeBtn = document.getElementById('weatherModalCloseBtn');
            if (closeBtn) closeBtn.focus();
            // Trap focus inside modal
            const modalOverlay = document.getElementById('weatherModalOverlay');
            const focusableSelectors = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            const modal = modalOverlay.querySelector('.weather-modal');
            const focusableEls = modal.querySelectorAll(focusableSelectors);
            const firstFocusable = focusableEls[0];
            const lastFocusable = focusableEls[focusableEls.length - 1];
            modalOverlay.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    if (focusableEls.length === 0) return;
                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            e.preventDefault();
                            lastFocusable.focus();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            e.preventDefault();
                            firstFocusable.focus();
                        }
                    }
                } else if (e.key === 'Escape') {
                    modalOverlay.remove();
                }
            });
            // Close logic
            closeBtn.onclick = () => {
                modalOverlay.remove();
            };
            modalOverlay.onclick = (e) => {
                if (e.target.id === 'weatherModalOverlay') {
                    modalOverlay.remove();
                }
            };
        }

        // Add event delegation for sparkline clicks after weather table is rendered
        function addSparklineListeners(hourlyByDay, dailyDates, hourlyPrecipByDay, hourlyWindByDay, tempUnit, precipUnit) {
            const table = document.querySelector('.weather-forecast-table');
            if (!table) return;
            table.addEventListener('click', function(e) {
                const svg = e.target.closest('svg[data-day-index]');
                if (svg) {
                    const dayIndex = parseInt(svg.getAttribute('data-day-index'));
                    if (!isNaN(dayIndex) && hourlyByDay[dayIndex]) {
                        showWeatherModal(
                            dayIndex,
                            dailyDates[dayIndex],
                            hourlyByDay[dayIndex],
                            hourlyPrecipByDay ? hourlyPrecipByDay[dayIndex] : null,
                            hourlyWindByDay ? hourlyWindByDay[dayIndex] : null
                        );
                    }
                }
            });
        }

        // On page load, check for cached location
        window.addEventListener('DOMContentLoaded', () => {
            const cached = localStorage.getItem('gardening_last_location');
            if (cached) {
                try {
                    const loc = JSON.parse(cached);
                    if (loc.type === 'query' && loc.value) {
                        locationInput.value = loc.value;
                        // Update clear button opacity
                        clearLocationBtn.style.opacity = '0.7';
                        geocodeLocation(loc.value);
                    } else if (loc.type === 'coords' && loc.lat && loc.lon) {
                        // Clear the input when using coordinates
                        locationInput.value = '';
                        clearLocationBtn.style.opacity = '0.2';
                        displayLocationInfo('Your location', loc.lat, loc.lon, '', '', '');
                    }
                } catch (e) {}
            }
        });
        
        // Handle clear button logic and input events
        const clearLocationBtn = document.getElementById('clearLocationBtn');
        
        // Show/hide clear button based on input content
        locationInput.addEventListener('input', function() {
            clearLocationBtn.style.opacity = this.value ? '0.7' : '0.2';
        });
        
        // Clear input when clear button is clicked
        clearLocationBtn.addEventListener('click', function() {
            locationInput.value = '';
            locationInput.focus();
            clearLocationBtn.style.opacity = '0.2';
        });
        
        // Set initial opacity for clear button
        clearLocationBtn.style.opacity = locationInput.value ? '0.7' : '0.2';
        
        // We're now using a single placeholder format for consistency

        // Geocoding API call
        async function geocodeLocation(query, isRetry = false) {
            // Track location search in Google Analytics
            if (typeof gtag === 'function' && !isRetry) {
                gtag('event', 'search_location', {
                    'search_term': query
                });
            }
            
            lastGeocodeQuery = query;
            lastWeatherAction = 'geocode';
            weatherPlaceholder.textContent = 'Looking up location...';
            // Cache the query
            localStorage.setItem('gardening_last_location', JSON.stringify({ type: 'query', value: query }));
            try {
                const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Geocoding service error');
                const data = await response.json();
                if (!data.results || data.results.length === 0) {
                    displayLocationError('Location not found. Please try a different name or postal code.', 'geocode');
                    return;
                }
                const result = data.results[0];
                displayLocationInfo(
                    result.name,
                    result.latitude,
                    result.longitude,
                    result.admin1,
                    result.admin2,
                    result.country
                );
            } catch (e) {
                displayLocationError('Could not resolve location. Please check your input and try again.', 'geocode');
            }
        }

        // Handle location input and search
        const searchLocationBtn = document.getElementById('searchLocationBtn');
        
        // Search when clicking the search button
        searchLocationBtn.addEventListener('click', function() {
            const query = locationInput.value.trim();
            if (query) geocodeLocation(query);
        });
        
        // Search when pressing Enter
        locationInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                const query = locationInput.value.trim();
                if (query) geocodeLocation(query);
            }
        });
        
        // We no longer search on blur to avoid unexpected behavior
        // This makes the UX more explicit - users must press Enter or the Search button

        // Handle 'Use my location' button
        useMyLocationBtn.addEventListener('click', function() {
            // Clear the input field when using geolocation
            locationInput.value = '';
            
            weatherPlaceholder.textContent = 'Getting your location...';
            if (!navigator.geolocation) {
                displayLocationError('Geolocation is not supported by your browser.', 'geocode');
                return;
            }
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    const lat = pos.coords.latitude.toFixed(5);
                    const lon = pos.coords.longitude.toFixed(5);
                    // Cache the coordinates
                    localStorage.setItem('gardening_last_location', JSON.stringify({ type: 'coords', lat, lon }));
                    displayLocationInfo('Your location', lat, lon, '', '', '');
                },
                (err) => {
                    displayLocationError('Could not get your location. Please allow location access or enter a place name.', 'geocode');
                }
            );
        });

        // Unit preference logic
        const tempUnitSelect = document.getElementById('tempUnitSelect');
        const precipUnitSelect = document.getElementById('precipUnitSelect');
        
        // Load preferences from localStorage
        function loadUnitPrefs() {
            const temp = localStorage.getItem('gardening_temp_unit');
            const precip = localStorage.getItem('gardening_precip_unit');
            
            if (temp && (temp === 'C' || temp === 'F')) tempUnitSelect.value = temp;
            if (precip && (precip === 'mm' || precip === 'in')) precipUnitSelect.value = precip;
        }
        
        // Save preferences to localStorage
        tempUnitSelect.addEventListener('change', () => {
            localStorage.setItem('gardening_temp_unit', tempUnitSelect.value);
            // Track event in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'change_preference', {
                    'preference_type': 'temperature_unit',
                    'value': tempUnitSelect.value
                });
            }
            if (lastWeatherData) renderWeatherData(lastWeatherData);
        });
        
        precipUnitSelect.addEventListener('change', () => {
            localStorage.setItem('gardening_precip_unit', precipUnitSelect.value);
            // Track event in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'change_preference', {
                    'preference_type': 'precipitation_unit',
                    'value': precipUnitSelect.value
                });
            }
            if (lastWeatherData) renderWeatherData(lastWeatherData);
        });
        
        // Language is now fixed to English
        
        // On page load, set unit preferences
        window.addEventListener('DOMContentLoaded', async () => {
            loadUnitPrefs();
            // Set fixed language to English
            currentLang = 'en';
            document.title = translations['en'].title;
            renderCalendar(activeMonth, searchBox?.value || '');
        });

        // Prompt Generator Logic
        const generatePromptBtn = document.getElementById('generatePromptBtn');
        const copyPromptBtn = document.getElementById('copyPromptBtn');
        const customNotes = document.getElementById('customNotes');
        const generatedPrompt = document.getElementById('generatedPrompt');
        const promptGeneratorModal = document.getElementById('promptGeneratorModal');
        const closePromptGeneratorBtn = document.getElementById('closePromptGeneratorBtn');
        const aiAdviceBtn = document.getElementById('aiAdviceBtn');
        const includeCalendar = document.getElementById('includeCalendar');
        const includeRelevantPlantsOnly = document.getElementById('includeRelevantPlantsOnly');

        // Modal handling
        function openPromptGenerator() {
            promptGeneratorModal.style.display = 'flex';
            customNotes.focus();
            // Store active element to restore focus later
            openPromptGenerator.previousActiveElement = document.activeElement;
        }

        function closePromptGenerator() {
            promptGeneratorModal.style.display = 'none';
            // Reset the generated prompt
            generatedPrompt.textContent = 'Click "Generate Prompt" to create a customized gardening prompt based on your location, weather, and calendar data.';
            // Hide AI assistants section
            document.getElementById('promptDestinationSection').style.display = 'none';
            // Clear custom notes
            customNotes.value = '';
            // Reset checkboxes to default state
            includeCalendar.checked = true;
            includeRelevantPlantsOnly.checked = true;
            // Restore focus
            if (openPromptGenerator.previousActiveElement) {
                openPromptGenerator.previousActiveElement.focus();
            }
        }

        // Add event listener for the AI advice button
        aiAdviceBtn.addEventListener('click', openPromptGenerator);

        // Close modal on escape or clicking outside
        promptGeneratorModal.addEventListener('click', (e) => {
            if (e.target === promptGeneratorModal) {
                closePromptGenerator();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && promptGeneratorModal.style.display === 'flex') {
                closePromptGenerator();
            }
        });

        closePromptGeneratorBtn.addEventListener('click', closePromptGenerator);

        function isPlantSuitableForWeather(plant, weatherData) {
            // Get temperature range for next 7 days
            const next7Days = weatherData.daily.temperature_2m_max.slice(0, 7);
            const maxTemp = Math.max(...next7Days);
            const minTemp = Math.min(...weatherData.daily.temperature_2m_min.slice(0, 7));
            const avgPrecip = weatherData.daily.precipitation_sum.slice(0, 7).reduce((a, b) => a + b, 0) / 7;

            // Basic suitability rules (these could be made more sophisticated)
            const coldSensitive = ['tomato', 'pepper', 'eggplant', 'cucumber', 'zucchini', 'pumpkin', 'melon', 'basil'];
            const heatSensitive = ['lettuce', 'spinach', 'arugula', 'peas'];
            const moistureSensitive = ['tomato', 'rosemary', 'thyme', 'sage'];

            // Ensure we have a string to work with
            const plantText = typeof plant === 'string' ? plant : '';
            const plantLower = plantText.toLowerCase();

            // Skip checks if we don't have valid plant text
            if (!plantLower) return true;

            // Check temperature suitability
            if (coldSensitive.some(p => plantLower.includes(p)) && minTemp < 10) return false;
            if (heatSensitive.some(p => plantLower.includes(p)) && maxTemp > 30) return false;
            
            // Check moisture suitability
            if (moistureSensitive.some(p => plantLower.includes(p)) && avgPrecip > 10) return false;

            return true;
        }

        function generatePrompt() {
            // Track prompt generation in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'generate_ai_prompt', {
                    'include_calendar': includeCalendar.checked,
                    'include_relevant_plants_only': includeRelevantPlantsOnly.checked
                });
            }
            
            // Get current location info
            let locationInfo = '';
            const weatherLocationInfo = document.querySelector('.weather-location-info');
            if (weatherLocationInfo) {
                locationInfo = weatherLocationInfo.textContent.trim();
            }

            // Get climate zone
            let climateZone = '';
            const climateZoneCode = document.getElementById('climateZoneCode');
            if (climateZoneCode) {
                climateZone = climateZoneCode.textContent.trim();
            }

            // Get current weather
            let currentWeather = '';
            const weatherCurrent = document.querySelector('.weather-current');
            if (weatherCurrent) {
                currentWeather = weatherCurrent.textContent.trim();
            }

            // Get forecast summary (next 7 days)
            let forecastSummary = '';
            const forecastTable = document.querySelector('.weather-forecast-table tbody');
            if (forecastTable) {
                const next7Days = Array.from(forecastTable.querySelectorAll('tr')).slice(0, 7);
                forecastSummary = next7Days.map(row => {
                    const cells = row.querySelectorAll('td');
                    const date = cells[0].textContent;
                    
                    // Extract weather condition and clean it up
                    let weatherText = cells[6].textContent.trim();
                    // Split by newline and get only the weather condition text (usually the second line)
                    let weatherParts = weatherText.split('\n').map(part => part.trim()).filter(part => part);
                    // Find the weather condition (not a temperature and not containing "selected")
                    let weatherCondition = weatherParts.find(part => 
                        !part.includes('¬∞') && !part.toLowerCase().includes('selected')
                    ) || "Not available";
                    
                    // Clean temperature information
                    const nightMinTemp = cells[1].textContent.trim().replace(/selected/gi, '');
                    const nightMaxTemp = cells[2].textContent.trim().replace(/selected/gi, '');
                    const dayMinTemp = cells[3].textContent.trim().replace(/selected/gi, '');
                    const dayMaxTemp = cells[4].textContent.trim().replace(/selected/gi, '');
                    const precipitation = cells[5].textContent.trim().replace(/selected/gi, '');
                    
                    // Build detailed forecast string
                    let dayForecast = `- ${date}:\n  Weather: ${weatherCondition}`;
                    
                    // Only add temps if they're not just "-"
                    if (nightMinTemp !== '-' && nightMaxTemp !== '-') {
                        dayForecast += `\n  Night: ${nightMinTemp} to ${nightMaxTemp}`;
                    }
                    
                    if (dayMinTemp !== '-' && dayMaxTemp !== '-') {
                        dayForecast += `\n  Day: ${dayMinTemp} to ${dayMaxTemp}`;
                    }
                    
                    dayForecast += `\n  Precipitation: ${precipitation}`;
                    
                    return dayForecast;
                }).join('\n\n');
            }

            // Get current month's planting calendar with only selected items
            let plantingCalendar = '';
            
            // Only include plant information if the includeCalendar checkbox is checked
            if (includeCalendar.checked) {
                // Retrieve the user's selected items from localStorage
                const selections = getSelectedItems();
                // Get only the selections for the current active month
                const currentSelections = selections[activeMonth];
                
                if (currentSelections && Object.keys(currentSelections).length > 0) {
                    const plantItems = [];
                    
                    // For debugging - log what's in currentSelections
                    console.log('Selected items for prompt:', JSON.stringify(currentSelections));
                    
                    // Process each category of selections
                    Object.entries(currentSelections).forEach(([category, selectedItems]) => {
                        if (selectedItems && selectedItems.length > 0) {
                            // Deep clone the items to avoid modification issues
                            let itemsToProcess = JSON.parse(JSON.stringify(selectedItems));
                            
                            // Make sure we're only working with the actual selected items
                            // by matching their IDs with what's in calendarData
                            const availableItems = calendarData[activeMonth]?.[category] || [];
                            
                            // Filter to ensure we only have valid selected items
                            itemsToProcess = itemsToProcess.filter(selectedItem => {
                                // Check if this item exists in calendarData for this month and category
                                return availableItems.some(item => {
                                    // Deep comparison by checking if the items are equivalent
                                    if (typeof selectedItem === 'object' && typeof item === 'object') {
                                        return selectedItem.en === item.en;
                                    }
                                    return false;
                                });
                            });
                            
                            // Filter based on weather suitability if that option is checked
                            if (includeRelevantPlantsOnly.checked && lastWeatherData) {
                                itemsToProcess = itemsToProcess.filter(item => {
                                    // Extract a text representation of the item for weather suitability check
                                    const plantName = typeof item === 'object' ? 
                                        (item[currentLang] || item.en || JSON.stringify(item)) : String(item);
                                    return isPlantSuitableForWeather(plantName, lastWeatherData);
                                });
                            }
                            
                            if (itemsToProcess.length > 0) {
                                // Format each item to display readable text
                                const formattedItems = itemsToProcess.map(item => {
                                    if (typeof item === 'object') {
                                        // Get the name in the current language or fall back to English
                                        return (item[currentLang] || item.en || JSON.stringify(item))
                                            .replace(/selected/gi, '') // Remove any "selected" text
                                            .trim();
                                    }
                                    return String(item).replace(/selected/gi, '').trim();
                                });
                                
                                // Remove any empty or duplicate items
                                const uniqueItems = [...new Set(formattedItems.filter(Boolean))];
                                
                                // Add the category with its items to the plantItems array
                                if (uniqueItems.length > 0) {
                                    plantItems.push(`${categoryNames[category] || category}:\n${uniqueItems.join('\n')}`);
                                }
                            }
                        }
                    });
                    
                    // Create the final calendar section if we have any items
                    if (plantItems.length > 0) {
                        plantingCalendar = 'Selected Plants and Tasks:\n\n' + plantItems.join('\n\n');
                    } else {
                        // If filtering for weather resulted in no suitable plants
                        if (includeRelevantPlantsOnly.checked) {
                            plantingCalendar = 'Note: The user has selected plants in the calendar, but none are suitable for the current weather forecast based on filtering criteria.\n';
                        } else {
                            plantingCalendar = 'No plants or tasks have been selected in the calendar yet.\n';
                        }
                    }
                } else {
                    // If no selections found for active month
                    plantingCalendar = 'No plants or tasks have been selected in the calendar yet.\n';
                }
            } else {
                // User has unchecked "Include selected plants and tasks"
                plantingCalendar = '';
            }

            // Get user's custom notes
            const notes = customNotes.value.trim();

            // Get current date
            const currentDate = new Date();
            const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
            const formattedDate = currentDate.toLocaleDateString(undefined, dateOptions);
            const currentSeason = (() => {
                const month = currentDate.getMonth();
                if (month >= 2 && month <= 4) return "Spring";
                if (month >= 5 && month <= 7) return "Summer";
                if (month >= 8 && month <= 10) return "Fall";
                return "Winter";
            })();

            // Construct the prompt
            const prompt = `I need advice for my garden based on the following information:

Current Date: ${formattedDate} (${currentSeason})

Location and Climate:
${locationInfo.replace(/Location:/g, "Location:").replace(/Latitude:/g, "\nLatitude:").replace(/Longitude:/g, "\nLongitude:")}

K√∂ppen Climate Zone: ${climateZone}
${includeRelevantPlantsOnly.checked && includeCalendar.checked ? '(Recommendations filtered for current weather conditions)' : ''}

Current Weather and Forecast:
${currentWeather}

7-Day Forecast:
${forecastSummary}
${plantingCalendar ? '\n' + plantingCalendar + '\n' : ''}
${notes ? `Additional Notes:\n${notes}\n\n` : ''}Based on this information, please provide:
1. Immediate tasks I should focus on this week
2. What I should plant now or prepare for planting
3. Potential weather-related precautions
4. Long-term planning suggestions
${includeCalendar.checked ? '5. Any specific care instructions for my selected plants' : '5. General gardening tips for this season and climate'}

IMPORTANT: This is a current gardening request for the date specified above. Please use the weather forecast and season information provided and do not base your recommendations on outdated or previous years' gardening calendars. The forecast and plants listed are current and specific to my location and climate.`;

            generatedPrompt.textContent = prompt;
            
            // Show AI assistants section
            document.getElementById('promptDestinationSection').style.display = 'block';
        }

        function copyPrompt() {
            navigator.clipboard.writeText(generatedPrompt.textContent)
                .then(() => {
                    const originalText = copyPromptBtn.textContent;
                    copyPromptBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyPromptBtn.textContent = originalText;
                    }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy text:', err);
                    alert('Failed to copy to clipboard. Please select and copy the text manually.');
                });
        }

        // Send prompt to AI assistant
        function sendToAiAssistant(assistant) {
            // Track which AI assistant was selected in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'send_to_ai_assistant', {
                    'assistant': assistant
                });
            }
            
            const prompt = encodeURIComponent(generatedPrompt.textContent);
            let url = '';
            
            switch(assistant) {
                case 'chatgpt':
                    url = `https://chat.openai.com?prompt=${prompt}`;
                    break;
                case 'claude':
                    url = `https://claude.ai/new?q=${prompt}`;
                    break;
                case 'gemini':
                    url = `https://gemini.google.com/app`;
                    break;
                case 'copilot':
                    url = `https://copilot.microsoft.com/?q=${prompt}`;
                    break;
                case 'mistral':
                    url = `https://chat.mistral.ai/chat`;
                    break;
                case 'deepseek':
                    url = `https://chat.deepseek.com`;
                    break;
                default:
                    alert('Selected AI assistant is not supported.');
                    return;
            }
            
            // Open in a new tab
            window.open(url, '_blank');
        }

        // Set up event listeners
        generatePromptBtn.addEventListener('click', generatePrompt);
        copyPromptBtn.addEventListener('click', copyPrompt);
        
        // AI assistant buttons
        document.querySelector('.ai-assistants-grid').addEventListener('click', (e) => {
            const btn = e.target.closest('.ai-assistant-btn');
            if (btn) {
                const assistant = btn.dataset.assistant;
                sendToAiAssistant(assistant);
            }
        });

        // Don't automatically generate on weather update anymore since it's in a modal
        const originalRenderWeatherData = renderWeatherData;
        renderWeatherData = function(data) {
            originalRenderWeatherData.call(this, data);
        };

        // Selection storage functionality
        function getSelectedItems() {
            const stored = localStorage.getItem('gardening_selected_items');
            return stored ? JSON.parse(stored) : {};
        }

        function isItemSelected(month, category, item) {
            const selections = getSelectedItems();
            
            // Check if we have any selections for this month and category
            if (!selections[month] || !selections[month][category]) {
                return false;
            }
            
            // For object items (like plants), compare by their English name
            if (typeof item === 'object' && item.en) {
                const matchFound = selections[month][category].some(selected => 
                    typeof selected === 'object' && selected.en === item.en
                );
                return matchFound;
            }
            
            // For string items or other types, use direct includes check
            return selections[month][category].includes(item);
        }

        function toggleItemSelection(month, category, item, selected) {
            const selections = getSelectedItems();
            
            // Initialize nested structure if needed
            if (!selections[month]) selections[month] = {};
            if (!selections[month][category]) selections[month][category] = [];
            
            const items = selections[month][category];
            
            // For object items (like plants), find by comparing English name
            let index = -1;
            if (typeof item === 'object' && item.en) {
                index = items.findIndex(existingItem => 
                    typeof existingItem === 'object' && existingItem.en === item.en
                );
            } else {
                // For string items or other types, use indexOf
                index = items.indexOf(item);
            }
            
            if (selected && index === -1) {
                // Store a clean copy without any DOM-related attributes
                if (typeof item === 'object') {
                    // We store only the essential data (language keys)
                    const cleanItem = { type: 'plant' };
                    if (item.en) cleanItem.en = item.en;
                    if (item.et) cleanItem.et = item.et;
                    items.push(cleanItem);
                } else {
                    items.push(item);
                }
            } else if (!selected && index !== -1) {
                // Log details of the deselected item for debugging
                console.log('Removing:', JSON.stringify(items[index]));
                items.splice(index, 1);
            }
            
            // Clean up empty arrays and objects
            if (items.length === 0) delete selections[month][category];
            if (Object.keys(selections[month]).length === 0) delete selections[month];
            
            // Save to localStorage
            localStorage.setItem('gardening_selected_items', JSON.stringify(selections));
            
            // Update "Select All" checkbox status
            updateSelectAllCheckbox(month, category);
            
            // Log the updated selections for debugging
            console.log('Item operation:', selected ? 'select' : 'deselect', item.en || item);
            console.log('Updated selections for', month, category, ':', JSON.stringify(selections[month]?.[category] || []));
        }

        // Function to update the select all checkbox based on individual item selections
        function updateSelectAllCheckbox(month, category) {
            const selectAllCheckbox = document.querySelector(`.select-all-checkbox[data-category="${category}"]`);
            if (!selectAllCheckbox) return;
            
            const categoryItems = calendarData[month][category] || [];
            if (categoryItems.length > 0) {
                // Check if ALL items in this category are selected
                let allSelected = true;
                for (let i = 0; i < categoryItems.length; i++) {
                    if (!isItemSelected(month, category, categoryItems[i])) {
                        allSelected = false;
                        break;
                    }
                }
                selectAllCheckbox.checked = allSelected;
                
                // Add debug log to help identify issues
                console.log(`Category: ${category}, All selected: ${allSelected}, Item count: ${categoryItems.length}`);
            }
        }

        // Garden Journal functionality
        // ----------------------------

        // Journal entry types
        const journalEntryTypes = {
            "planting": { icon: "üå±", name: "Planting" },
            "care": { icon: "üåø", name: "Garden Care" },
            "harvest": { icon: "ü•ï", name: "Harvest" },
            "observation": { icon: "üëÅÔ∏è", name: "Observation" },
            "maintenance": { icon: "üß∞", name: "Maintenance" }
        };

        // Get all journal entries
        function getJournalEntries() {
            const stored = localStorage.getItem('gardening_journal_entries');
            return stored ? JSON.parse(stored) : [];
        }

        // Save all journal entries
        function saveJournalEntries(entries) {
            localStorage.setItem('gardening_journal_entries', JSON.stringify(entries));
        }

        // Create a new journal entry
        function createJournalEntry(entryData) {
            const entries = getJournalEntries();
            const newEntry = {
                id: `journal-${Date.now()}`,
                date: entryData.date || new Date().toISOString().split('T')[0],
                type: entryData.type || 'observation',
                plants: entryData.plants || [],
                notes: entryData.notes || '',
                location: entryData.location || '',
                metrics: entryData.metrics || {},
                images: entryData.images || [],
                weather: lastWeatherData ? {
                    temperature: lastWeatherData.current_weather.temperature,
                    weatherCode: lastWeatherData.current_weather.weathercode,
                    precipitation: lastWeatherData.daily.precipitation_sum[0] || 0
                } : null,
                timestamp: Date.now()
            };
            
            entries.push(newEntry);
            saveJournalEntries(entries);
            return newEntry;
        }

        // Update an existing journal entry
        function updateJournalEntry(id, updatedData) {
            const entries = getJournalEntries();
            const index = entries.findIndex(entry => entry.id === id);
            
            if (index !== -1) {
                entries[index] = { ...entries[index], ...updatedData, timestamp: Date.now() };
                saveJournalEntries(entries);
                return entries[index];
            }
            
            return null;
        }

        // Delete a journal entry
        function deleteJournalEntry(id) {
            const entries = getJournalEntries();
            const newEntries = entries.filter(entry => entry.id !== id);
            
            if (newEntries.length !== entries.length) {
                saveJournalEntries(newEntries);
                return true;
            }
            
            return false;
        }

        // Get the total localStorage usage (as a percentage of estimated available space)
        function getStorageUsage() {
            let total = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    total += (localStorage[key].length * 2) / 1024 / 1024; // Approximate MB
                }
            }
            // Most browsers have ~5MB limit
            return {
                used: total.toFixed(2),
                percentage: (total / 5 * 100).toFixed(1)
            };
        }
        
        // Convert a File object to base64 for storage
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }
        
        // Compress an image before storage
        function compressImage(base64Image, maxWidth = 800, quality = 0.7) {
            return new Promise((resolve) => {
                const img = new Image();
                img.src = base64Image;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxWidth) {
                        height = Math.round(height * maxWidth / width);
                        width = maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Get the compressed image
                    const compressedBase64 = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedBase64);
                };
            });
        }
        
        // Generate a thumbnail from a base64 image
        function generateThumbnail(base64Image, size = 150) {
            return compressImage(base64Image, size, 0.5);
        }

        // Add scroll-related event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const scrollToTop = document.getElementById('scrollToTop');
            const calendarContent = document.getElementById('calendarContent');
            const quickJumpMenu = document.getElementById('quickJumpMenu');
            const header = document.querySelector('header');

            // Handle header scroll state
            function updateHeaderState() {
                if (window.pageYOffset > 50) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }
            }

            // Throttle scroll event handling
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                if (!scrollTimeout) {
                    scrollTimeout = setTimeout(() => {
                        updateHeaderState();
                        scrollTimeout = null;
                    }, 10);
                }
            });

            // Initial header state
            updateHeaderState();

            // Quick jump functionality
            quickJumpMenu.addEventListener('click', (e) => {
                const btn = e.target.closest('.quick-jump-btn');
                if (!btn) return;
                
                // Remove active class from all buttons
                quickJumpMenu.querySelectorAll('.quick-jump-btn').forEach(b => b.classList.remove('active'));
                
                const sectionId = btn.dataset.section;
                const section = document.getElementById(sectionId);
                
                if (section) {
                    // Add active class to clicked button
                    btn.classList.add('active');
                    
                    // Scroll to section with offset for header
                    const headerHeight = document.querySelector('header').offsetHeight;
                    const sectionTop = section.getBoundingClientRect().top + window.pageYOffset;
                    window.scrollTo({
                        top: sectionTop - headerHeight - 20,
                        behavior: 'smooth'
                    });

                    // If it's the garden journal, make sure it's visible
                    if (sectionId === 'garden-journal') {
                        document.querySelectorAll('section').forEach(s => {
                            s.style.display = s.id === 'garden-journal' ? 'block' : 'none';
                        });
                        renderJournal(); // Make sure journal content is up to date
                    } else {
                        // For other sections, hide garden journal and show everything else
                        document.getElementById('garden-journal').style.display = 'none';
                        document.querySelectorAll('section:not(#garden-journal)').forEach(s => {
                            s.style.display = 'block';
                        });
                    }
                }
            });

            // Garden Journal event handlers
            const addJournalEntryBtn = document.getElementById('addJournalEntryBtn');
            const emptyJournalAddBtn = document.getElementById('emptyJournalAddBtn');
            const closeJournalEntryBtn = document.getElementById('closeJournalEntryBtn');
            const cancelJournalEntryBtn = document.getElementById('cancelJournalEntryBtn');
            const journalEntryForm = document.getElementById('journalEntryForm');
            const journalEntryModal = document.getElementById('journalEntryModal');
            const entryType = document.getElementById('entryType');
            const harvestMetricsContainer = document.getElementById('harvestMetricsContainer');
            const harvestQuality = document.getElementById('harvestQuality');
            const qualityRatingText = document.getElementById('qualityRatingText');
            const photoInput = document.getElementById('photoInput');
            const photoUploadContainer = document.getElementById('photoUploadContainer');
            const photoPreviewContainer = document.getElementById('photoPreviewContainer');
            const journalTabs = document.querySelectorAll('.journal-tab');

            // Populate plants dropdown from calendar data
            const entryPlants = document.getElementById('entryPlants');
            const populatePlantsDropdown = () => {
                // Clear current options
                entryPlants.innerHTML = '';
                
                // Create a set to store unique plant names
                const uniquePlants = new Set();
                
                // Add all plants from all months
                Object.values(calendarData).forEach(monthData => {
                    Object.keys(monthData).forEach(category => {
                        // Only include plant categories (not tasks)
                        if (category !== 'garden_tasks') {
                            monthData[category].forEach(plant => {
                                if (typeof plant === 'object' && plant.en) {
                                    uniquePlants.add(plant.en);
                                } else if (typeof plant === 'string') {
                                    uniquePlants.add(plant);
                                }
                            });
                        }
                    });
                });
                
                // Sort plants alphabetically
                const sortedPlants = Array.from(uniquePlants).sort();
                
                // Add options to the select
                sortedPlants.forEach(plant => {
                    const option = document.createElement('option');
                    option.value = plant;
                    option.textContent = plant;
                    entryPlants.appendChild(option);
                });
            };

            // Check storage usage and show warning if needed
            const checkStorageUsage = () => {
                const usage = getStorageUsage();
                const storageWarning = document.getElementById('storageWarning');
                
                if (parseFloat(usage.percentage) > 70) {
                    storageWarning.style.display = 'block';
                    storageWarning.textContent = `Storage usage: ${usage.percentage}% (${usage.used} MB). Consider removing some photos or exporting your journal.`;
                } else {
                    storageWarning.style.display = 'none';
                }
            };

            // Add entry button click handler
            addJournalEntryBtn.addEventListener('click', () => openJournalEntryModal());
            emptyJournalAddBtn.addEventListener('click', () => openJournalEntryModal());

            // Close modal buttons
            closeJournalEntryBtn.addEventListener('click', () => journalEntryModal.style.display = 'none');
            cancelJournalEntryBtn.addEventListener('click', () => journalEntryModal.style.display = 'none');

            // Show harvest metrics if type is harvest
            entryType.addEventListener('change', () => {
                harvestMetricsContainer.style.display = entryType.value === 'harvest' ? 'block' : 'none';
            });

            // Update quality rating text based on slider
            harvestQuality.addEventListener('input', () => {
                const value = parseInt(harvestQuality.value);
                const ratings = ['Poor', 'Fair', 'Good', 'Very Good', 'Excellent'];
                qualityRatingText.textContent = ratings[value - 1];
            });

            // Tab switching logic
            journalTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs
                    journalTabs.forEach(t => t.classList.remove('active'));
                    
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    
                    // Show corresponding content
                    const view = tab.dataset.view;
                    document.getElementById('journalTimeline').style.display = view === 'timeline' ? 'block' : 'none';
                    document.getElementById('journalGallery').style.display = view === 'gallery' ? 'block' : 'none';
                    document.getElementById('journalCalendar').style.display = view === 'calendar' ? 'block' : 'none';
                    
                    // If showing the gallery, make sure it's rendered
                    if (view === 'gallery') {
                        renderGallery();
                    } else if (view === 'calendar') {
                        renderJournalCalendar();
                    }
                });
            });

            // Photo upload handling
            photoInput.addEventListener('change', handlePhotoSelection);
            
            // Drag and drop for photos
            photoUploadContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                photoUploadContainer.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
                photoUploadContainer.style.backgroundColor = 'rgba(74, 142, 58, 0.1)';
            });
            
            photoUploadContainer.addEventListener('dragleave', () => {
                photoUploadContainer.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
                photoUploadContainer.style.backgroundColor = '';
            });
            
            photoUploadContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                photoUploadContainer.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
                photoUploadContainer.style.backgroundColor = '';
                
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    handlePhotoSelection({ target: { files: e.dataTransfer.files } });
                }
            });
            
            // Click to browse files
            document.querySelector('label[for="photoInput"]').addEventListener('click', () => {
                photoInput.click();
            });

            // Form submission
            journalEntryForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                // Get form data
                const entryId = document.getElementById('journalEntryId').value;
                const entryData = {
                    date: document.getElementById('entryDate').value,
                    type: document.getElementById('entryType').value,
                    location: document.getElementById('entryLocation').value,
                    plants: Array.from(document.getElementById('entryPlants').selectedOptions).map(opt => opt.value),
                    notes: document.getElementById('entryNotes').value,
                    images: []
                };
                
                // If it's a harvest entry, add metrics
                if (entryData.type === 'harvest') {
                    entryData.metrics = {
                        quantity: document.getElementById('harvestQuantity').value,
                        unit: document.getElementById('harvestUnit').value,
                        quality: document.getElementById('harvestQuality').value
                    };
                }
                
                // Process images
                const imageElements = photoPreviewContainer.querySelectorAll('.photo-preview');
                for (const imgEl of imageElements) {
                    const imgSrc = imgEl.querySelector('img').src;
                    // Only add the image if it's not already a placeholder
                    if (!imgSrc.includes('placeholder')) {
                        entryData.images.push(imgSrc);
                    }
                }
                
                // Save or update the entry
                if (entryId) {
                    updateJournalEntry(entryId, entryData);
                } else {
                    createJournalEntry(entryData);
                }
                
                // Close modal and reload journal
                journalEntryModal.style.display = 'none';
                renderJournal();
            });

            // Check storage and populate plants on page load
            checkStorageUsage();
            populatePlantsDropdown();
            
            // Function to open the journal entry modal (new or edit)
            function openJournalEntryModal(entryId = null) {
                // Reset form
                journalEntryForm.reset();
                document.getElementById('journalEntryId').value = '';
                photoPreviewContainer.innerHTML = '';
                document.getElementById('journalEntryModalTitle').textContent = 'Add Journal Entry';
                
                // Set today's date as default
                document.getElementById('entryDate').value = new Date().toISOString().split('T')[0];
                
                // Hide harvest metrics by default
                harvestMetricsContainer.style.display = 'none';
                
                // If editing an existing entry
                if (entryId) {
                    const entries = getJournalEntries();
                    const entry = entries.find(e => e.id === entryId);
                    
                    if (entry) {
                        document.getElementById('journalEntryModalTitle').textContent = 'Edit Journal Entry';
                        document.getElementById('journalEntryId').value = entry.id;
                        document.getElementById('entryDate').value = entry.date;
                        document.getElementById('entryType').value = entry.type;
                        document.getElementById('entryLocation').value = entry.location || '';
                        document.getElementById('entryNotes').value = entry.notes || '';
                        
                        // Set plants
                        if (entry.plants && entry.plants.length) {
                            const selectOptions = document.getElementById('entryPlants').options;
                            for (let i = 0; i < selectOptions.length; i++) {
                                selectOptions[i].selected = entry.plants.includes(selectOptions[i].value);
                            }
                        }
                        
                        // Show harvest metrics if needed
                        if (entry.type === 'harvest') {
                            harvestMetricsContainer.style.display = 'block';
                            if (entry.metrics) {
                                document.getElementById('harvestQuantity').value = entry.metrics.quantity || '';
                                document.getElementById('harvestUnit').value = entry.metrics.unit || 'kg';
                                document.getElementById('harvestQuality').value = entry.metrics.quality || 3;
                                
                                // Update quality text
                                const value = parseInt(entry.metrics.quality) || 3;
                                const ratings = ['Poor', 'Fair', 'Good', 'Very Good', 'Excellent'];
                                qualityRatingText.textContent = ratings[value - 1];
                            }
                        }
                        
                        // Add existing images as previews
                        if (entry.images && entry.images.length) {
                            entry.images.forEach(imgSrc => {
                                const previewDiv = document.createElement('div');
                                previewDiv.className = 'photo-preview';
                                previewDiv.style.position = 'relative';
                                previewDiv.style.width = '100px';
                                previewDiv.style.height = '100px';
                                
                                const img = document.createElement('img');
                                img.src = imgSrc;
                                img.style.width = '100%';
                                img.style.height = '100%';
                                img.style.objectFit = 'cover';
                                img.style.borderRadius = '8px';
                                
                                const removeBtn = document.createElement('button');
                                removeBtn.innerHTML = '&times;';
                                removeBtn.style.position = 'absolute';
                                removeBtn.style.top = '5px';
                                removeBtn.style.right = '5px';
                                removeBtn.style.background = 'rgba(0, 0, 0, 0.5)';
                                removeBtn.style.color = 'white';
                                removeBtn.style.border = 'none';
                                removeBtn.style.borderRadius = '50%';
                                removeBtn.style.width = '24px';
                                removeBtn.style.height = '24px';
                                removeBtn.style.cursor = 'pointer';
                                removeBtn.style.display = 'flex';
                                removeBtn.style.alignItems = 'center';
                                removeBtn.style.justifyContent = 'center';
                                
                                removeBtn.addEventListener('click', () => {
                                    previewDiv.remove();
                                    checkStorageUsage();
                                });
                                
                                previewDiv.appendChild(img);
                                previewDiv.appendChild(removeBtn);
                                photoPreviewContainer.appendChild(previewDiv);
                            });
                        }
                    }
                }
                
                // Show modal
                journalEntryModal.style.display = 'flex';
            }
            
            // Handle photo selection from input or drag and drop
            async function handlePhotoSelection(e) {
                const files = e.target.files;
                if (!files || files.length === 0) return;
                
                // Check if we've reached the limit
                const currentPhotos = photoPreviewContainer.querySelectorAll('.photo-preview').length;
                const remainingSlots = 5 - currentPhotos;
                
                if (remainingSlots <= 0) {
                    alert('Maximum 5 photos per entry. Please remove some photos before adding more.');
                    return;
                }
                
                // Process only up to the remaining slots
                const filesToProcess = Array.from(files).slice(0, remainingSlots);
                
                for (const file of filesToProcess) {
                    // Create preview immediately with placeholder
                    const previewDiv = document.createElement('div');
                    previewDiv.className = 'photo-preview';
                    previewDiv.style.position = 'relative';
                    previewDiv.style.width = '100px';
                    previewDiv.style.height = '100px';
                    
                    const img = document.createElement('img');
                    img.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlMGUwZTAiLz48dGV4dCB4PSI1MCIgeT0iNTAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzlFOUU5RSI+TG9hZGluZy4uLjwvdGV4dD48L3N2Zz4='; // Loading placeholder
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '8px';
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.innerHTML = '&times;';
                    removeBtn.style.position = 'absolute';
                    removeBtn.style.top = '5px';
                    removeBtn.style.right = '5px';
                    removeBtn.style.background = 'rgba(0, 0, 0, 0.5)';
                    removeBtn.style.color = 'white';
                    removeBtn.style.border = 'none';
                    removeBtn.style.borderRadius = '50%';
                    removeBtn.style.width = '24px';
                    removeBtn.style.height = '24px';
                    removeBtn.style.cursor = 'pointer';
                    removeBtn.style.display = 'flex';
                    removeBtn.style.alignItems = 'center';
                    removeBtn.style.justifyContent = 'center';
                    
                    removeBtn.addEventListener('click', () => {
                        previewDiv.remove();
                        checkStorageUsage();
                    });
                    
                    previewDiv.appendChild(img);
                    previewDiv.appendChild(removeBtn);
                    photoPreviewContainer.appendChild(previewDiv);
                    
                    // Process image in background
                    try {
                        // Convert to base64
                        const base64Image = await fileToBase64(file);
                        
                        // Compress image
                        const compressed = await compressImage(base64Image);
                        
                        // Update preview with compressed image
                        img.src = compressed;
                        
                        // Check storage
                        checkStorageUsage();
                    } catch (error) {
                        console.error('Error processing image:', error);
                        previewDiv.remove();
                    }
                }
                
                // Hide text if we have photos
                document.getElementById('dragDropText').style.display = 
                    photoPreviewContainer.querySelectorAll('.photo-preview').length > 0 ? 'none' : 'block';
            }

            // Initialize journal if we're on that tab
            if (window.location.hash === '#garden-journal') {
                // Find and click the journal tab to activate it
                const journalBtn = document.querySelector('.quick-jump-btn[data-section="garden-journal"]');
                if (journalBtn) journalBtn.click();
            }
            
            // Add event listeners for Export/Import buttons
            const exportJournalBtn = document.getElementById('exportJournalBtn');
            const importJournalBtn = document.getElementById('importJournalBtn');
            
            if (exportJournalBtn) {
                exportJournalBtn.addEventListener('click', function() {
                    // Show export options modal instead of confirm dialog
                    showExportOptionsModal();
                });
            }
            
            if (importJournalBtn) {
                importJournalBtn.addEventListener('click', function() {
                    // Create file input element
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'application/json';
                    
                    fileInput.onchange = (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const importData = JSON.parse(event.target.result);
                                
                                // Validate data format
                                if (!Array.isArray(importData)) {
                                    throw new Error('Invalid format: Data should be an array of journal entries');
                                }
                                
                                // Show import options modal
                                showImportOptionsModal(importData);
                                
                            } catch (error) {
                                console.error('Import error:', error);
                                alert(`Error importing journal: ${error.message}`);
                            }
                        };
                        
                        reader.readAsText(file);
                    };
                    
                    // Trigger file selection
                    fileInput.click();
                });
            }
        });

        // Check storage and populate plants on page load
        checkStorageUsage();
        populatePlantsDropdown();
        
        // Render journal functions
        function renderJournal() {
            const entries = getJournalEntries();
            const emptyMessage = document.getElementById('emptyJournalMessage');
            const journalTimeline = document.getElementById('journalTimeline');
            
            // Show/hide empty message
            if (entries.length === 0) {
                emptyMessage.style.display = 'block';
                journalTimeline.style.display = 'none';
                // Also hide the tabs if empty
                document.querySelector('.journal-tabs').style.display = 'none';
                return;
            } else {
                emptyMessage.style.display = 'none';
                journalTimeline.style.display = 'block';
                document.querySelector('.journal-tabs').style.display = 'flex';
            }
            
            // Render the timeline
            renderTimeline();
            
            // Render gallery if it's visible
            const galleryTab = document.querySelector('.journal-tab[data-view="gallery"]');
            if (galleryTab.classList.contains('active')) {
                renderGallery();
            }
            
            // Render calendar if it's visible
            const calendarTab = document.querySelector('.journal-tab[data-view="calendar"]');
            if (calendarTab.classList.contains('active')) {
                renderJournalCalendar();
            }
        }
        
        function renderTimeline() {
            const entries = getJournalEntries();
            const journalTimeline = document.getElementById('journalTimeline');
            
            // Sort entries by date (newest first)
            entries.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Generate HTML for timeline
            let html = '';
            
            entries.forEach(entry => {
                const entryType = journalEntryTypes[entry.type] || { icon: 'üìù', name: 'Note' };
                const dateObj = new Date(entry.date);
                const formattedDate = dateObj.toLocaleDateString(undefined, {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                // Start entry card
                html += `
                    <div class="journal-entry-card" style="margin-bottom: 20px; padding: 15px; background: #f9f9f9; border-radius: 8px; border-left: 4px solid var(--secondary-color);">
                        <div style="display: flex; align-items: center; margin-bottom: 10px;">
                            <div style="font-size: 1.5rem; margin-right: 10px;">${entryType.icon}</div>
                            <div style="flex-grow: 1;">
                                <div style="font-weight: 500; color: var(--primary-color);">${entryType.name}</div>
                                <div style="font-size: 0.9rem; color: #666;">${formattedDate}</div>
                            </div>
                            <div>
                                <button class="edit-entry-btn" data-entry-id="${entry.id}" style="background: none; border: none; cursor: pointer; margin-right: 5px;">‚úèÔ∏è</button>
                                <button class="delete-entry-btn" data-entry-id="${entry.id}" style="background: none; border: none; cursor: pointer;">üóëÔ∏è</button>
                            </div>
                        </div>`;
                
                // Plants section (if any)
                if (entry.plants && entry.plants.length > 0) {
                    html += `<div style="margin-bottom: 10px;">
                        <div style="font-weight: 500; margin-bottom: 5px;">Plants:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 5px;">`;
                    
                    entry.plants.forEach(plant => {
                        html += `<span style="background: var(--light-bg); padding: 3px 8px; border-radius: 12px; font-size: 0.9rem;">${plant}</span>`;
                    });
                    
                    html += `</div></div>`;
                }
                
                // Location (if any)
                if (entry.location) {
                    html += `<div style="margin-bottom: 10px;">
                        <div style="font-weight: 500; margin-bottom: 5px;">Location:</div>
                        <div>${entry.location}</div>
                    </div>`;
                }
                
                // Harvest metrics (if it's a harvest entry)
                if (entry.type === 'harvest' && entry.metrics) {
                    const qualityStars = '‚òÖ'.repeat(parseInt(entry.metrics.quality) || 0) + '‚òÜ'.repeat(5 - (parseInt(entry.metrics.quality) || 0));
                    
                    html += `<div style="margin-bottom: 10px;">
                        <div style="font-weight: 500; margin-bottom: 5px;">Harvest:</div>
                        <div style="display: flex; gap: 15px;">
                            <div>Quantity: ${entry.metrics.quantity || 'n/a'} ${entry.metrics.unit || ''}</div>
                            <div>Quality: <span style="color: #FFC107;">${qualityStars}</span></div>
                        </div>
                    </div>`;
                }
                
                // Weather at the time (if available)
                if (entry.weather) {
                    const weatherIcon = entry.weather.weatherCode !== undefined 
                        ? weatherCodeToIconTextColor(entry.weather.weatherCode).icon 
                        : 'üå°Ô∏è';
                        
                    const weatherText = entry.weather.weatherCode !== undefined 
                        ? weatherCodeToIconTextColor(entry.weather.weatherCode).text 
                        : '';
                        
                    html += `<div style="margin-bottom: 10px; font-size: 0.9rem; color: #666;">
                        <div style="font-weight: 500; margin-bottom: 5px;">Weather:</div>
                        <div>${weatherIcon} ${entry.weather.temperature !== undefined ? entry.weather.temperature + '¬∞' : ''} ${weatherText}</div>
                    </div>`;
                }
                
                // Notes (if any)
                if (entry.notes) {
                    html += `<div style="margin-bottom: 10px;">
                        <div style="font-weight: 500; margin-bottom: 5px;">Notes:</div>
                        <div style="white-space: pre-wrap;">${entry.notes}</div>
                    </div>`;
                }
                
                // Images (if any)
                if (entry.images && entry.images.length > 0) {
                    html += `<div style="margin-top: 15px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 10px;">`;
                    
                    entry.images.forEach((imgSrc, index) => {
                        html += `<div class="journal-image" style="width: 100px; height: 100px; cursor: pointer;" data-full-img="${imgSrc}" data-entry-id="${entry.id}" data-img-index="${index}">
                            <img src="${imgSrc}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;" alt="Journal image">
                        </div>`;
                    });
                    
                    html += `</div></div>`;
                }
                
                // Close entry card
                html += `</div>`;
            });
            
            journalTimeline.innerHTML = html;
            
            // Add event listeners for edit/delete buttons
            journalTimeline.querySelectorAll('.edit-entry-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const entryId = btn.dataset.entryId;
                    openJournalEntryModal(entryId);
                });
            });
            
            journalTimeline.querySelectorAll('.delete-entry-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const entryId = btn.dataset.entryId;
                    showDeleteConfirmModal(entryId);
                });
            });
            
            // Add event listeners for image lightbox
            journalTimeline.querySelectorAll('.journal-image').forEach(img => {
                img.addEventListener('click', () => {
                    const fullImg = img.dataset.fullImg;
                    showImageLightbox(fullImg);
                });
            });
        }
        
        function renderGallery() {
            const entries = getJournalEntries();
            const journalGallery = document.getElementById('journalGallery');
            
            // Get all images from all entries
            const allImages = [];
            entries.forEach(entry => {
                if (entry.images && entry.images.length > 0) {
                    entry.images.forEach((imgSrc, index) => {
                        allImages.push({
                            src: imgSrc,
                            date: entry.date,
                            entryId: entry.id,
                            imgIndex: index
                        });
                    });
                }
            });
            
            // Sort by date (newest first)
            allImages.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Build gallery HTML
            let html = '';
            
            if (allImages.length === 0) {
                html = `<div style="text-align: center; padding: 40px 20px;">
                    <div style="font-size: 3rem; margin-bottom: 20px;">üì∑</div>
                    <h3 style="margin-bottom: 15px; color: var(--primary-color);">No Photos Yet</h3>
                    <p style="margin-bottom: 20px; color: #666;">Add photos to your journal entries to see them here!</p>
                </div>`;
            } else {
                html = `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px;">`;
                
                allImages.forEach(img => {
                    const dateObj = new Date(img.date);
                    const formattedDate = dateObj.toLocaleDateString(undefined, {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });
                    
                    html += `<div class="gallery-image" style="cursor: pointer;" data-full-img="${img.src}" data-entry-id="${img.entryId}">
                        <div style="position: relative; padding-bottom: 100%;">
                            <img src="${img.src}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 8px;" alt="Garden photo">
                            <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.5); color: white; padding: 5px 8px; font-size: 0.8rem; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;">${formattedDate}</div>
                        </div>
                    </div>`;
                });
                
                html += `</div>`;
            }
            
            journalGallery.innerHTML = html;
            
            // Add event listeners for image lightbox
            journalGallery.querySelectorAll('.gallery-image').forEach(img => {
                img.addEventListener('click', () => {
                    const fullImg = img.dataset.fullImg;
                    const entryId = img.dataset.entryId;
                    showImageLightbox(fullImg, entryId);
                });
            });
        }
        
        function renderJournalCalendar() {
            const entries = getJournalEntries();
            const journalCalendar = document.getElementById('journalCalendar');
            
            // Group entries by month/year
            const entriesByMonth = {};
            
            entries.forEach(entry => {
                const date = new Date(entry.date);
                const month = date.getMonth();
                const year = date.getFullYear();
                const key = `${year}-${month}`;
                
                if (!entriesByMonth[key]) {
                    entriesByMonth[key] = [];
                }
                
                entriesByMonth[key].push(entry);
            });
            
            // Sort months chronologically (newest first)
            const sortedMonths = Object.keys(entriesByMonth).sort().reverse();
            
            // Build calendar HTML
            let html = '';
            
            if (sortedMonths.length === 0) {
                html = `<div style="text-align: center; padding: 40px 20px;">
                    <div style="font-size: 3rem; margin-bottom: 20px;">üìÖ</div>
                    <h3 style="margin-bottom: 15px; color: var(--primary-color);">No Journal Entries Yet</h3>
                    <p style="margin-bottom: 20px; color: #666;">Add entries to your garden journal to see them in the calendar!</p>
                </div>`;
            } else {
                sortedMonths.forEach(monthKey => {
                    const [year, month] = monthKey.split('-').map(Number);
                    const date = new Date(year, month, 1);
                    const monthName = date.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
                    
                    html += `<div style="margin-bottom: 30px;">
                        <h3 style="margin-bottom: 15px; padding-bottom: 8px; border-bottom: 1px solid #e0e0e0; color: var(--primary-color);">${monthName}</h3>
                        <div style="display: flex; flex-direction: column; gap: 10px;">`;
                    
                    // Get entries for this month and sort by date
                    const monthEntries = entriesByMonth[monthKey];
                    monthEntries.sort((a, b) => new Date(b.date) - new Date(a.date));
                    
                    // Group by day
                    const entriesByDay = {};
                    monthEntries.forEach(entry => {
                        const day = new Date(entry.date).getDate();
                        if (!entriesByDay[day]) entriesByDay[day] = [];
                        entriesByDay[day].push(entry);
                    });
                    
                    // Sort days and create calendar items
                    const sortedDays = Object.keys(entriesByDay).map(Number).sort((a, b) => b - a);
                    
                    sortedDays.forEach(day => {
                        const dayDate = new Date(year, month, day);
                        const dayName = dayDate.toLocaleDateString(undefined, { weekday: 'long', day: 'numeric' });
                        
                        html += `<div style="display: flex; gap: 15px;">
                            <div style="flex: 0 0 60px; text-align: center; font-weight: 500; padding-top: 5px;">
                                <div style="font-size: 1.1rem;">${day}</div>
                                <div style="font-size: 0.8rem; color: #666;">${dayDate.toLocaleDateString(undefined, { weekday: 'short' })}</div>
                            </div>
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 8px;">`;
                        
                        entriesByDay[day].forEach(entry => {
                            const entryType = journalEntryTypes[entry.type] || { icon: 'üìù', name: 'Note' };
                            
                            html += `<div class="calendar-entry" style="cursor: pointer; padding: 8px 12px; background: #f1f8e9; border-radius: 6px; display: flex; align-items: center;" data-entry-id="${entry.id}">
                                <div style="margin-right: 10px; font-size: 1.1rem;">${entryType.icon}</div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 500;">${entryType.name}</div>
                                    <div style="font-size: 0.9rem; color: #666; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${entry.plants && entry.plants.length ? entry.plants.join(', ') : (entry.notes ? entry.notes.substring(0, 30) + (entry.notes.length > 30 ? '...' : '') : 'No details')}</div>
                                </div>
                                ${entry.images && entry.images.length ? `<div style="width: 30px; text-align: center; font-size: 0.9rem;">üì∑${entry.images.length}</div>` : ''}
                            </div>`;
                        });
                        
                        html += `</div></div>`;
                    });
                    
                    html += `</div></div>`;
                });
            }
            
            journalCalendar.innerHTML = html;
            
            // Add event listeners for calendar entries
            journalCalendar.querySelectorAll('.calendar-entry').forEach(entry => {
                entry.addEventListener('click', () => {
                    const entryId = entry.dataset.entryId;
                    
                    // Switch to timeline view and scroll to the entry
                    const timelineTab = document.querySelector('.journal-tab[data-view="timeline"]');
                    timelineTab.click();
                    
                    // Wait for the timeline to render and then scroll to the entry
                    setTimeout(() => {
                        const entryElement = document.querySelector(`.journal-entry-card [data-entry-id="${entryId}"]`).closest('.journal-entry-card');
                        if (entryElement) {
                            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            entryElement.style.background = '#e8f5e9';
                            setTimeout(() => {
                                entryElement.style.transition = 'background-color 1s';
                                entryElement.style.background = '#f9f9f9';
                            }, 100);
                        }
                    }, 100);
                });
            });
        }
        
        function showImageLightbox(imgSrc, entryId = null) {
            // Remove any existing lightbox
            const oldLightbox = document.getElementById('imageLightbox');
            if (oldLightbox) oldLightbox.remove();
            
            // Create lightbox
            const lightbox = document.createElement('div');
            lightbox.id = 'imageLightbox';
            lightbox.style.position = 'fixed';
            lightbox.style.top = '0';
            lightbox.style.left = '0';
            lightbox.style.width = '100%';
            lightbox.style.height = '100%';
            lightbox.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            lightbox.style.display = 'flex';
            lightbox.style.alignItems = 'center';
            lightbox.style.justifyContent = 'center';
            lightbox.style.zIndex = '9999';
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '20px';
            closeBtn.style.right = '20px';
            closeBtn.style.backgroundColor = 'transparent';
            closeBtn.style.border = 'none';
            closeBtn.style.color = 'white';
            closeBtn.style.fontSize = '2rem';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.zIndex = '10000';
            closeBtn.addEventListener('click', () => lightbox.remove());
            
            // Add image
            const img = document.createElement('img');
            img.src = imgSrc;
            img.style.maxWidth = '90%';
            img.style.maxHeight = '90%';
            img.style.boxShadow = '0 5px 30px rgba(0, 0, 0, 0.3)';
            
            // Add caption if entry ID is provided
            if (entryId) {
                const entries = getJournalEntries();
                const entry = entries.find(e => e.id === entryId);
                
                if (entry) {
                    const caption = document.createElement('div');
                    caption.style.position = 'absolute';
                    caption.style.bottom = '20px';
                    caption.style.left = '0';
                    caption.style.width = '100%';
                    caption.style.textAlign = 'center';
                    caption.style.color = 'white';
                    caption.style.padding = '10px';
                    caption.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                    
                    const dateObj = new Date(entry.date);
                    const formattedDate = dateObj.toLocaleDateString(undefined, {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    
                    caption.textContent = `${formattedDate} - ${journalEntryTypes[entry.type]?.name || 'Journal Entry'}`;
                    
                    lightbox.appendChild(caption);
                }
            }
            
            // Add to document
            lightbox.appendChild(closeBtn);
            lightbox.appendChild(img);
            document.body.appendChild(lightbox);
            
            // Add click event to close on background click
            lightbox.addEventListener('click', (e) => {
                if (e.target === lightbox) {
                    lightbox.remove();
                }
            });
            
            // Add escape key to close
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('imageLightbox')) {
                    document.getElementById('imageLightbox').remove();
                }
            });
        }
        
        // Function to open the journal entry modal (new or edit)
        function openJournalEntryModal(entryId = null) {
            // Reset form
            journalEntryForm.reset();
            document.getElementById('journalEntryId').value = '';
            photoPreviewContainer.innerHTML = '';
            document.getElementById('journalEntryModalTitle').textContent = 'Add Journal Entry';
            
            // Set today's date as default
            document.getElementById('entryDate').value = new Date().toISOString().split('T')[0];
            
            // Hide harvest metrics by default
            harvestMetricsContainer.style.display = 'none';
            
            // If editing an existing entry
            if (entryId) {
                const entries = getJournalEntries();
                const entry = entries.find(e => e.id === entryId);
                
                if (entry) {
                    document.getElementById('journalEntryModalTitle').textContent = 'Edit Journal Entry';
                    document.getElementById('journalEntryId').value = entry.id;
                    document.getElementById('entryDate').value = entry.date;
                    document.getElementById('entryType').value = entry.type;
                    document.getElementById('entryLocation').value = entry.location || '';
                    document.getElementById('entryNotes').value = entry.notes || '';
                    
                    // Set plants
                    if (entry.plants && entry.plants.length) {
                        const selectOptions = document.getElementById('entryPlants').options;
                        for (let i = 0; i < selectOptions.length; i++) {
                            selectOptions[i].selected = entry.plants.includes(selectOptions[i].value);
                        }
                    }
                    
                    // Show harvest metrics if needed
                    if (entry.type === 'harvest') {
                        harvestMetricsContainer.style.display = 'block';
                        if (entry.metrics) {
                            document.getElementById('harvestQuantity').value = entry.metrics.quantity || '';
                            document.getElementById('harvestUnit').value = entry.metrics.unit || 'kg';
                            document.getElementById('harvestQuality').value = entry.metrics.quality || 3;
                            
                            // Update quality text
                            const value = parseInt(entry.metrics.quality) || 3;
                            const ratings = ['Poor', 'Fair', 'Good', 'Very Good', 'Excellent'];
                            qualityRatingText.textContent = ratings[value - 1];
                        }
                    }
                    
                    // Add existing images as previews
                    if (entry.images && entry.images.length) {
                        entry.images.forEach(imgSrc => {
                            const previewDiv = document.createElement('div');
                            previewDiv.className = 'photo-preview';
                            previewDiv.style.position = 'relative';
                            previewDiv.style.width = '100px';
                            previewDiv.style.height = '100px';
                            
                            const img = document.createElement('img');
                            img.src = imgSrc;
                            img.style.width = '100%';
                            img.style.height = '100%';
                            img.style.objectFit = 'cover';
                            img.style.borderRadius = '8px';
                            
                            const removeBtn = document.createElement('button');
                            removeBtn.innerHTML = '&times;';
                            removeBtn.style.position = 'absolute';
                            removeBtn.style.top = '5px';
                            removeBtn.style.right = '5px';
                            removeBtn.style.background = 'rgba(0, 0, 0, 0.5)';
                            removeBtn.style.color = 'white';
                            removeBtn.style.border = 'none';
                            removeBtn.style.borderRadius = '50%';
                            removeBtn.style.width = '24px';
                            removeBtn.style.height = '24px';
                            removeBtn.style.cursor = 'pointer';
                            removeBtn.style.display = 'flex';
                            removeBtn.style.alignItems = 'center';
                            removeBtn.style.justifyContent = 'center';
                            
                            removeBtn.addEventListener('click', () => {
                                previewDiv.remove();
                                checkStorageUsage();
                            });
                            
                            previewDiv.appendChild(img);
                            previewDiv.appendChild(removeBtn);
                            photoPreviewContainer.appendChild(previewDiv);
                        });
                    }
                }
            }
            
            // Show modal
            journalEntryModal.style.display = 'flex';
        }

        // Export journal to JSON file
        function exportJournal(includeImages = true) {
            const entries = getJournalEntries();
            
            // If no entries, show message
            if (entries.length === 0) {
                alert('No journal entries to export.');
                return;
            }
            
            // Clone entries to avoid modifying the original data
            let exportData = JSON.parse(JSON.stringify(entries));
            
            // Remove images if not including them
            if (!includeImages) {
                exportData = exportData.map(entry => {
                    const entryCopy = {...entry};
                    delete entryCopy.images;
                    return entryCopy;
                });
            }
            
            // Create the export file
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            // Generate filename with timestamp
            const date = new Date().toISOString().slice(0, 10);
            const filename = `garden_journal_${date}${includeImages ? '_with_images' : '_no_images'}.json`;
            
            // Create download link and trigger download
            const link = document.createElement('a');
            link.setAttribute('href', dataUri);
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Import journal from JSON file
        function importJournal() {
            // Create file input element
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'application/json';
            
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importData = JSON.parse(event.target.result);
                        
                        // Validate data format
                        if (!Array.isArray(importData)) {
                            throw new Error('Invalid format: Data should be an array of journal entries');
                        }
                        
                        // Show import options modal
                        showImportOptionsModal(importData);
                        
                    } catch (error) {
                        console.error('Import error:', error);
                        alert(`Error importing journal: ${error.message}`);
                    }
                };
                
                reader.readAsText(file);
            };
            
            // Trigger file selection
            fileInput.click();
        }
        
        // Export without images (lightweight version)
        function exportLightweightJournal() {
            exportJournal(false);
        }

        // Custom modal functions
        function showCustomConfirmModal(title, message, onConfirm, confirmText = 'Confirm', cancelText = 'Cancel') {
            const modal = document.getElementById('customConfirmModal');
            const titleElement = document.getElementById('confirmModalTitle');
            const messageElement = document.getElementById('confirmModalMessage');
            const okBtn = document.getElementById('confirmModalOkBtn');
            const cancelBtn = document.getElementById('confirmModalCancelBtn');
            
            // Set content
            titleElement.textContent = title;
            messageElement.textContent = message;
            okBtn.textContent = confirmText;
            cancelBtn.textContent = cancelText;
            
            // Set actions
            okBtn.onclick = () => {
                modal.style.display = 'none';
                if (onConfirm) onConfirm(true);
            };
            
            cancelBtn.onclick = () => {
                modal.style.display = 'none';
                if (onConfirm) onConfirm(false);
            };
            
            // Show modal
            modal.style.display = 'flex';
        }
        
        function showExportOptionsModal() {
            const modal = document.getElementById('exportOptionsModal');
            const exportOptions = modal.querySelectorAll('.export-option');
            const cancelBtn = document.getElementById('exportOptionsCancelBtn');
            const closeBtn = document.getElementById('exportModalCloseBtn');
            
            // Clear any previous selections
            exportOptions.forEach(option => {
                option.style.borderColor = '#ddd';
                option.style.backgroundColor = 'transparent';
            });
            
            // Set click behavior for options
            exportOptions[0].onclick = () => {
                modal.style.display = 'none';
                exportJournal(true); // Full export with images
            };
            
            exportOptions[1].onclick = () => {
                modal.style.display = 'none';
                exportJournal(false); // Lightweight export without images
            };
            
            // Add hover effects
            exportOptions.forEach(option => {
                option.onmouseover = () => {
                    if (option.style.borderColor !== 'var(--primary-color)') {
                        option.style.backgroundColor = '#f5f5f5';
                    }
                };
                
                option.onmouseout = () => {
                    if (option.style.borderColor !== 'var(--primary-color)') {
                        option.style.backgroundColor = 'transparent';
                    }
                };
            });
            
            // Cancel and close buttons close the modal
            cancelBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            closeBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            // Click outside to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
            
            // Show modal
            modal.style.display = 'flex';
            
            // Setup escape key handler
            const handleEscapeKey = (e) => {
                if (e.key === 'Escape') {
                    modal.style.display = 'none';
                    document.removeEventListener('keydown', handleEscapeKey);
                }
            };
            document.addEventListener('keydown', handleEscapeKey);
        }
        
        function showImportOptionsModal(importData) {
            const modal = document.getElementById('importOptionsModal');
            const importOptions = modal.querySelectorAll('.import-option');
            const cancelBtn = document.getElementById('importOptionsCancelBtn');
            const closeBtn = document.getElementById('importModalCloseBtn');
            const statsMessage = document.getElementById('importStatsMessage');
            
            // Update the stats message
            statsMessage.textContent = `Found ${importData.length} journal ${importData.length === 1 ? 'entry' : 'entries'} to import.`;
            
            // Clear any previous selections
            importOptions.forEach(option => {
                option.style.borderColor = '#ddd';
                option.style.backgroundColor = 'transparent';
            });
            
            // Set click behavior for options
            importOptions[0].onclick = () => {
                // Merge option
                modal.style.display = 'none';
                handleImport(importData, true);
            };
            
            importOptions[1].onclick = () => {
                // Replace option
                modal.style.display = 'none';
                handleImport(importData, false);
            };
            
            // Add hover effects
            importOptions.forEach(option => {
                option.onmouseover = () => {
                    if (option.style.borderColor !== 'var(--primary-color)') {
                        option.style.backgroundColor = '#f5f5f5';
                    }
                };
                
                option.onmouseout = () => {
                    if (option.style.borderColor !== 'var(--primary-color)') {
                        option.style.backgroundColor = 'transparent';
                    }
                };
            });
            
            // Cancel and close buttons close the modal
            cancelBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            closeBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            // Click outside to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
            
            // Show modal
            modal.style.display = 'flex';
            
            // Setup escape key handler
            const handleEscapeKey = (e) => {
                if (e.key === 'Escape') {
                    modal.style.display = 'none';
                    document.removeEventListener('keydown', handleEscapeKey);
                }
            };
            document.addEventListener('keydown', handleEscapeKey);
        }
        
        function showDeleteConfirmModal(entryId) {
            const modal = document.getElementById('deleteConfirmModal');
            const confirmBtn = document.getElementById('deleteConfirmBtn');
            const cancelBtn = document.getElementById('deleteConfirmCancelBtn');
            const closeBtn = document.getElementById('deleteModalCloseBtn');
            
            // Set the delete action
            confirmBtn.onclick = () => {
                deleteJournalEntry(entryId);
                renderJournal();
                modal.style.display = 'none';
            };
            
            // Cancel and close buttons close the modal
            cancelBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            closeBtn.onclick = () => {
                modal.style.display = 'none';
            };
            
            // Click outside to close
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
            
            // Show modal
            modal.style.display = 'flex';
            
            // Setup escape key handler
            const handleEscapeKey = (e) => {
                if (e.key === 'Escape') {
                    modal.style.display = 'none';
                    document.removeEventListener('keydown', handleEscapeKey);
                }
            };
            document.addEventListener('keydown', handleEscapeKey);
        }
        
        function handleImport(importData, isMerge) {
                        const existingEntries = getJournalEntries();
                        
            if (isMerge) {
                            // Merge: Keep existing entries and add new ones
                            const mergedEntries = [...existingEntries];
                            
                            // Track stats for user feedback
                            let added = 0;
                            let updated = 0;
                            
                            importData.forEach(importEntry => {
                                const existingIndex = mergedEntries.findIndex(e => e.id === importEntry.id);
                                
                                if (existingIndex >= 0) {
                                    // Update existing entry
                                    mergedEntries[existingIndex] = importEntry;
                                    updated++;
                                } else {
                                    // Add new entry
                                    mergedEntries.push(importEntry);
                                    added++;
                                }
                            });
                            
                            // Save merged entries
                            saveJournalEntries(mergedEntries);
                            
                            // Show success message
                alert(`Import successful!\nAdded ${added} new ${added === 1 ? 'entry' : 'entries'}\nUpdated ${updated} existing ${updated === 1 ? 'entry' : 'entries'}`);
                        } else {
                            // Replace: Delete all existing entries and use imported ones
                            saveJournalEntries(importData);
                            
                            // Show success message
                alert(`Import successful!\nReplaced all entries with ${importData.length} imported ${importData.length === 1 ? 'entry' : 'entries'}`);
                        }
                        
                        // Refresh the journal display
                        renderJournal();
        }
    </script>
</body>
</html> 